# üìö My FlexiQuiz Learning Series 

Welcome to my curated collection of quizzes hosted on [FlexiQuiz](https://www.flexiquiz.com). 

These quizes cover broad topics like human-centered design, BPMN, software testing, Java programming, cryptography, software security, web security, and algorithms & data structures. All quizes come with question explanations as help.

Almost all of the quizes are content from subjects at NTNU Trondheim, several of them are old exams questions from previous exams.
These quizzes cover broad topics such as human-centered design, software testing, data science, model driven development, Java programming, cryptography, software security, web security, and algorithms and data structures. They are grouped into simple series that move from basics to more advanced ideas for easy study and review

<br/>

---


#  Software Testing and Quality Series - TDT4242

<details>
  <summary>Click to expand</summary>

A series focused on core software testing concepts, methodologies, and best practices.
 
**Advanced Software Engineering** focuses on methods for developing reliable and complex software systems, including safety-critical and AI-assisted applications.  
**Requirements specification** ‚Äì turning stakeholder needs into precise technical requirements.  
**Testing management** ‚Äì planning and automating modern test processes.  
**Code quality** ‚Äì using static analysis, peer review, and refactoring.  
**Verification & validation** ‚Äì evaluating large-scale and AI-driven systems.  

- [Software Testing and Quality Quiz ‚Äì Part 1](https://www.flexiquiz.com/SC/N/SoftwareTesting1) - TDT4242
  Covers basic testing terminology, unit testing, and manual testing fundamentals.

- [Software Testing and Quality Quiz ‚Äì Part 2](https://www.flexiquiz.com/SC/N/SoftwareTesting2) - TDT4242
  Explores automated testing, integration testing, and test strategies.

- [Software Testing and Quality Quiz ‚Äì Part 3](https://www.flexiquiz.com/SC/N/SoftwareTesting3) - TDT4242
  Delves into testing methodologies.

- [Software Testing and Quality Quiz ‚Äì Part 4](https://www.flexiquiz.com/SC/N/SoftwareTesting4) - TDT4242
  Examines advanced topics like performance testing and test coverage metrics.

- [Software Testing and Quality Quiz ‚Äì Part 5](https://www.flexiquiz.com/SC/N/SoftwareTesting5) - TDT4242
  Explores requirements engineering and test setup.

- [Software Testing and Quality Quiz ‚Äì Part 6](https://www.flexiquiz.com/SC/N/SoftwareTesting6) - TDT4242
  Explores code smells, DU-coverage and Devops.

- [Software Testing and Quality Quiz ‚Äì Part 7](https://www.flexiquiz.com/SC/N/SoftwareTesting7) - TDT4242
  Explores domain testing, code smells, sustainability, all-pair combinatorial tests, and Devops terms
  |                          |                                     |
  |--------------------------|-------------------------------------|
  | DevOps Metrics           | Lead Time, Cycle Time, PCA          |
  | Combinatorial Testing    | All-pairs test design               |
  | Code Quality             | Code smells & refactoring           |
  | Sustainable Applications | Efficiency, scalability, accessibility |
  | Domain Testing           | Valid vs. invalid domains           |
  | Equivalence Partitioning | Input classes for test coverage     |
  | Boundary Value Analysis  | Edge cases of input ranges          |
  | Interior vs Exterior     | Just inside/outside domain values   |
  | Numeric Boundaries       | Age, salary, numeric ranges         |
  | Non-numeric Boundaries   | Password length, registration dates |


- [Software Testing and Quality Quiz - Part 8](https://www.flexiquiz.com/SC/N/SoftwareTesting8) - TDT4242
  Explores code refactoring, testing concepts, requirements quality, requirements classification, sustainable software requirements, branch and statement coverage.

  |                       |                      |
  |-----------------------|----------------------|
  | Refactoring           | Testing techniques   |
  | Test levels           | Quality attributes   |
  | Non-functional reqs   | Sustainability       |
  | Safety                | Test cases           |
  | Requirements quality  | Traceability         |
  | Coverage              | Random testing       |
  | Statement vs branch   | Adaptive testing     |

</details>

<br/>
<br/>
<br/>

---


#  Java Programming - TDT4100

<details>
  <summary>Click to expand</summary>

Based onm exam questions in the subject TDT4100 at NTNU Trondheim.

- [Java Programming Exam Questions](https://www.flexiquiz.com/SC/N/JavaExam1)  

  |                        |                       |
  |------------------------|-----------------------|
  | Lambda expressions     | Collections           |
  | Primitive types        | Default values        |
  | Delegation             | Observer pattern      |
  | Inheritance            | Polymorphism          |
  | Design patterns        | Strategy & Factory    |
  | Streams & Matching     | Functional interfaces |
  | Encapsulation          | Object structure      |
  | Interfaces             | Abstract classes      |
  | Access modifiers       | Visibility            |
  | Method overloading     | Method overriding     |

</details>

<br/>
<br/>
<br/>

---


#  Cryptography Fundamentals - TDT4237

<details>
  <summary>Click to expand</summary>

A concise introduction to the world of secure communications and encryption techniques.

- [Cryptography Basics Quiz](https://www.flexiquiz.com/SC/N/Cryptography1)  
  
  |                            |                           |
  |----------------------------|---------------------------|
  | Block ciphers              | Rounds in ciphers         |
  | HMAC                       | Message authentication    |
  | Elliptic Curve Cryptography| Public-key efficiency     |
  | Certification Authorities  | Trust models              |
  | Public keys                | Private keys              |
  | Authentication             | Encryption                |
  | Security models            | Cryptographic evaluation  |
  | Cryptographic techniques   | Data protection           |

</details>

<br/>
<br/>
<br/>

---


#  Software Security Series - TDT4237

<details>
  <summary>Click to expand</summary>

A comprehensive series covering secure development practices and application-level security.

- [Software Security ‚Äì Part 1](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart1) - TDT4237
  
  |                                                |                                                          |
  |------------------------------------------------|----------------------------------------------------------|
  | Recommended secure coding practices            | Symmetric encryption use in secure transmission          |
  | Asymmetric encryption (public/private keys)    | CVE vs CVSS purposes                                     |
  | Good security requirements                     | CIA Triad (Confidentiality, Integrity, Availability)     |
  | ROI of countermeasures after a data breach     | Defenses against session hijacking                       |
  | Buffer overflow defenses                       | Symmetric vs asymmetric encryption disadvantages         |
  | Django password validator implementation       | Weaknesses of password authentication & improvements     |
  | Psychological factors in social engineering    | Malicious AI attacks on recognition systems              |
  | Salt & pepper in cryptography (hashing)        | Conditions when salt fails                               |

- [Software Security ‚Äì Part 2](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart2) - TDT4237

  |                                                  |                                                        |
  |--------------------------------------------------|--------------------------------------------------------|
  | Buffer overflow in C code                        | Secure coding practices (captchas, defenses)           |
  | Command injection attack                         | False cryptography statements                          |
  | Key generation best practices                    | Threat agent characteristics                           |
  | String concatenation vulnerability               | XML external entity (XXE) risk                         |
  | Storing passwords securely (hashing, salting)    | Other sensitive data exposure vulnerabilities          |
  | CVSS scoring metrics (Heartbleed case)           | Token exploitation and protection                      |
  | Insecure logging configuration                   | Secure logging and monitoring                          |
  | One-Time Pad encryption & properties             | OTP key reuse vulnerabilities                          |
  | Biba vs Bell-LaPadula models                     | Penetration testing and applications                   |
  | PoisingGPT attack steps                          | DevOps software deployment attack steps                |
  | Risk analysis threat dimensions                  | Zero-day exploit description                           |


- [Software Security ‚Äì Part 3](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart3) - TDT4237

  |                                                 |                                                    |
  |-------------------------------------------------|----------------------------------------------------|
  | SQL injection vulnerability in Django code      | Secure coding fix for raw SQL                      |
  | Recommended secure practices                    | CIA triad violation                                |
  | Password policy exceptions                      | Sensitive information exposure vulnerabilities     |
  | Vulnerability prioritization (CVSS scoring)     | Common Vulnerability Scoring System (CVSS)         |
  | Common Vulnerabilities and Exposures (CVE)      | Importance of updating NuGet packages              |
  | Insecure web parameters (URL issues)            | CVE vs CVSS purposes                               |
  | Asymmetric key usage                            | Backdoors in software                              |
  | Countermeasure cost vs asset value              | Phishing/email scam defense                        |
  | Taboo traps in machine learning                 | Lawful consent under GDPR                          |
  | Logic bomb attack                               | Unicode sabotage in translation systems            |
  | Password policy enforcement in Django           | Secure logging and monitoring configuration        |


- [Software Security ‚Äì Part 4](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart4) - TDT4237
  
  |                                                  |                                                       |
  |--------------------------------------------------|-------------------------------------------------------|
  | GDPR L-F-D-A-S-I-A fields                        | Business goals and business assets                    |
  | Business risks and risk dimensions               | Misuse case diagram and threat agent ranking          |
  | Attack tree for QR code misuse                   | Technical risks linked to business risks              |
  | Security requirements for technical risks        | GDPR violation discussion in crisis contexts          |
  | Machine learning use and misuse in identity      | GDPR principles (Art. 5)                              |
  | GDPR key points and legal bases                  | GDPR breach notification requirements                 |


- [Software Security - Part 5](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart5) - TDT4237

  |                                       |                                                     |
  |---------------------------------------|-----------------------------------------------------|
  | STRIDE threat categories              | Rule-Set-Based Access Control (RSBAC)               |
  | Organization-Based Access Control     | Lattice-Based Access Control (LBAC)                 |
  | Graph-Based Access Control (GBAC)     | Context-Based Access Control (CBAC)                 |
  | Bell-LaPadula model                   | Biba model                                          |
  | Clark-Wilson model                    | Brewer-Nash (Cinderella) model                      |
  | Password salting defenses             | Security by Design principles                       |
  | Bell-LaPadula vs Biba differences     | Bell-LaPadula vs Biba similarities                  |
  | Secure coding practices               | Security testing and code review                    |
  | Principle of least privilege          | Patch management strategy                           |
  | Access control mechanisms             | Common access control models                        |


</details>

<br/>
<br/>
<br/>

---


#  Web Application Security Series - TDT4237

<details>
  <summary>Click to expand</summary>

A deep dive into common web vulnerabilities and how to prevent them.

### > Web Security ‚Äì Part 1
---  
- Quiz: [Web Security ‚Äì Part 1](https://www.flexiquiz.com/SC/N/WebSecPart1) - TDT4237

  |                                              |                                                     |
  |----------------------------------------------|-----------------------------------------------------|
  | Session hijacking techniques                 | Man-in-the-Middle (MITM) attack                     |
  | Cross-Site Request Forgery (CSRF)            | Cross-Site Scripting (XSS)                          |
  | XSS protection for session hijacking         | CSRF protection for session hijacking               |
  | CORS overview                                | CORS misconfiguration vulnerabilities               |
  | Server injection attack types                | SQL injection defense via parameterization          |


### > Web Security ‚Äì Part 2
---  
- Quiz: [Web Security ‚Äì Part 2](https://www.flexiquiz.com/SC/N/WebSecPart2) - TDT4237

  |                                      |                                                     |
  |--------------------------------------|-----------------------------------------------------|
  | File upload attacks                  | XSS mitigation techniques                           |
  | Real-world CSRF example (Twitter)    | CSRF mitigation strategies                          |
  | Session cookie protection methods    | Web server information leakage prevention           |
  | Risks of not using HTTPS             | Clickjacking prevention                             |
  | Email fraud prevention               | Cookie protection rationale                         |


### > Web Security ‚Äì Part 3
---  
- Quiz: [Web Security ‚Äì Part 3](https://www.flexiquiz.com/SC/N/WebSecPart3) - TDT4237

  |                                                  |                                                      |
  |--------------------------------------------------|------------------------------------------------------|
  | HTTP vs cookie-based authentication              | XSS, CSRF, and XSSI differences                      |
  | Stored XSS vs Reflected XSS                      | CSRF and Referer header limitations                  |
  | Action tokens in CSRF protection                 | Token and cookie combination defense                 |
  | XSS prevention methods                           | HTTP header vulnerability rationale                  |
  | HTTP header injection examples                   | Content-Type sniffing and XSS risks                  |
  | Reducing XSS impact                              | Recommended XSS mitigation practices                 |


### > Web Security ‚Äì Part 4
---  
- Quiz: [Web Security ‚Äì Part 4](https://www.flexiquiz.com/SC/N/WebSecPart4) - TDT4237
 
  |                                   |                                     |
  |-----------------------------------|-------------------------------------|
  | Web security best practices       | STRIDE threat model                 |
  | Environmental creep               | Access control models               |
  | Bell-LaPadula principles          | Bell-LaPadula rules                 |
  | SAML SSO components               | SAML use cases                      |
  | Stack overflow causes             | Call stack behavior                 |
  | Memory overflow types             | Memory safety across languages      |
  | Unsafe defaults in C/C++          | Safe defaults in C#                 |
  | Website copier tools              | HTTrack and VisualWget usage        |
  | Web debugging proxies             | Firefox Dev Tools and Fiddler       |
  | Security toolkits                 | Burp Suite, OWASP ZAP, Kali Linux   |
  | Google Dorking operators          | SSRF attack scenarios               |
  | Rainbow table protection          | Security by Design ‚Äì goal           |
  | Least privilege principle         | Threat modeling importance          |

</details>

<br/>
<br/>
<br/>

---
#  Algorithms and Data Structures - TDT4120
<details>
  <summary>Click to expand</summary>

**Content:**  
- Efficiency analysis, recursion, divide-and-conquer  
- Ordering, searching, sorting, hashing  
- Dynamic programming & greedy methods  
- Graph algorithms: shortest path, matching, spanning tree, max flow  
- Basics of complexity theory  

**Learning outcome:**  
- Recognise and apply a wide range of algorithms  
- Analyse time/space costs  
- Design new solutions when needed  
- Foundation for later AI, cyber-security, and systems courses


### > Algorithms and Data Structures ‚Äì Part 1 - TDT4120
---
*NP basics, loop invariants & correctness, simple algorithms (selection/linear search), Master Theorem template, and order-of-growth ranking.*

Quiz: [Algorithms and Data Structures ‚Äì Part 1](https://www.flexiquiz.com/SC/N/Algdat1)

**Covers & focus**
- [Lecture 1 ‚Äì Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer) ‚Üê **highest focus**
- [Lecture 3 ‚Äì Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk)
- [Lecture 13 ‚Äì NP-kompletthet](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-13---np-kompletthet)

| Topic                          | Brief description |
|-------------------------------------------|-------------------|
| Why NP-complete matters                    | If any NP-complete problem has a poly-time algorithm, all problems in NP do (poly-time reductions). |
| TSP vs shortest path                       | Both are path problems; shortest path is poly-time; TSP is NP-hard/NP-complete (decision). |
| Exact vs approximate                       | When optimality is required vs ‚Äúgood enough‚Äù (approximation/heuristics). |
| Offline vs online                          | Entire input known up-front vs arrives over time (online algorithms, competitiveness). |
| Loop invariants (init/maint/term)          | Specify invariant, prove initialization, maintenance, termination (SUM-ARRAY, selection sort). |
| Selection sort facts                       | Maintains: A[1..i‚àí1] sorted and ‚â§ remaining; runs i=1..n‚àí1; Œò(n¬≤) worst/avg; best is also Œò(n¬≤). |
| Linear search                              | Average Œò(n), worst Œò(n); simple invariant over scanned prefix. |
| Master Theorem form                        | T(n) = a¬∑T(n/b) + f(n); know the template and how to fill the blanks. |
| Two-sum in Œò(n log n)                      | Sort + two-pointer scan; outline steps and correctness idea. |
| Complexity ranking & simplification        | Rank common classes; combine Œò/O/Œ© terms to a single tight order. |

---

### > Algorithms and Data Structures ‚Äì Part 2 - TDT4120
---
*Asymptotic notation, sorting runtimes, greedy property, SSSP (Dijkstra vs Bellman‚ÄìFord), MST (Kruskal), and flow basics.*

Quiz: [Algorithms and Data Structures ‚Äì Part 2](https://www.flexiquiz.com/SC/N/Algdat2)

**Covers & focus**
- [Lecture 1 ‚Äì Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 ‚Äì Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk)
- [Lecture 7 ‚Äì Gr√•dige algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-7---gr%C3%A5dige-algoritmer)
- [Lecture 9 ‚Äì Minimale spenntr√¶r](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-9---minimale-spenntr%C3%A6r)
- [Lecture 10 ‚Äì Korteste vei fra √©n til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-10---korteste-vei-fra-%C3%A9n-til-alle) ‚Üê **highest focus**

| Topic                          | Brief description |
|-------------------------------------------|-------------------|
| Asymptotic notation                       | Œò (tight), O (upper), Œ© (lower), o (strictly smaller), œâ (strictly larger). Match common forms to names. |
| Combine bounds                            | O(n·µÉ) + Œ©(n·µá) + Œò(n·∂ú) ‚Üí dominated by the largest-order term among the three. |
| Compare functions                         | Given f and g (e.g., f = n¬≤ log n + ‚Ä¶, g = n¬≤), decide O/Œ©/Œò via limits/ratios and dominant terms. |
| Sorting runtimes                          | Insertion: best n, avg n¬≤, worst n¬≤. Merge: best/avg/worst n log n. Quick: best/avg n log n, worst n¬≤. |
| Relax(u, v, w)                            | If dist[v] > dist[u] + w(u,v), set dist[v] ‚Üê dist[u] + w and parent[v] ‚Üê u. Core of SSSP updates. |
| Dijkstra vs Bellman‚ÄìFord                  | Dijkstra (greedy) for non-negative edges; Bellman‚ÄìFord handles negatives and detects negative cycles. |
| Greedy-choice property                    | A locally optimal step can be extended to a global optimum; still need proof via cut/exchange arguments. |
| Kruskal and MST                           | MST: spanning tree with minimum total weight. Kruskal: sort edges, add safe light edges using union-find. |
| Pivot selection in Quicksort              | Pivot choice shapes balance: random keeps expected n log n; bad fixed pivots on sorted data risk n¬≤. |
| Flow vs complexity (Ford‚ÄìFulkerson)       | Pseudopolynomial due to capacity magnitudes, not NP-hardness of max-flow (max-flow is polynomial-time). |


---

### > Algorithms and Data Structures ‚Äì Part 3 - TDT4120
---
*Greedy algorithms, sorting family (QS/Rand-QS/Select/Heap/Merge/Insertion), data structures (heaps vs BSTs, splay), asymptotics & NP, MST/flow basics, and the Master Theorem.*

Quiz: [Algorithms and Data Structures ‚Äì Part 3](https://www.flexiquiz.com/SC/N/Algdat3)

**Covers & focus**
- [Lecture 1 ‚Äì Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 ‚Äì Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk)
- [Lecture 4 ‚Äì Rangering i line√¶r tid](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-4---rangering-i-line%C3%A6r-tid)
- [Lecture 5 ‚Äì Rotfaste trestrukturer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-5---rotfaste-trestrukturer)
- [Lecture 7 ‚Äì Gr√•dige algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-7---gr%C3%A5dige-algoritmer) ‚Üê **highest focus**
- [Lecture 9 ‚Äì Minimale spenntr√¶r](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-9---minimale-spenntr%C3%A6r)
- [Lecture 12 ‚Äì Maksimal flyt](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-12---maksimal-flyt)
- [Lecture 13 ‚Äì NP-kompletthet](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-13---np-kompletthet)

| Topic                  | Brief description |
|-----------------------------------|-------------------|
| Greedy choice property            | Locally optimal step extends to a global optimum; classic examples: activity selection, Huffman, Kruskal. |
| Heaps vs binary trees             | When heaps beat BSTs for priority access; array layout vs pointer-based trees; max-heap vs BST order. |
| Splay trees                       | Self-adjusting BSTs that move accessed nodes near the root by rotations; good amortized performance. |
| Naive recursion ‚Üí improvement     | Exponential naive D&C improved by **memoization/tabulation** when optimal substructure + overlap hold. |
| Sorting family contrasts          | Quick vs Randomized-Quick; Select vs Randomized-Select; effects of using Select inside Quick. |
| Sorting facts (per algorithm)     | Best/avg/worst, stability, space for Insertion, Merge, Quick, Rand-Quick, Heap. |
| Complexity classes                | P, NP, NP-complete: verification vs search; reductions to show hardness. |
| MST basics                        | What an MST is; Prim vs Kruskal (PQ vs sort + union-find); cut and cycle properties. |
| Max-flow (Ford‚ÄìFulkerson)        | Augmenting paths, residual graphs; pseudo-polynomial due to capacity magnitude. |
| Master Theorem                    | Template T(n)=a¬∑T(n/b)+f(n); identify case via n^{log_b a} and compare with f(n). |


---

### > Algorithms and Data Structures ‚Äì Part 4 - TDT4120
---
*Asymptotic notation & properties, lower bounds via crossings, little-o/œâ, Master Theorem basics, and merge-sort recurrence.*

Quiz: [Algorithms and Data Structures ‚Äì Part 4](https://www.flexiquiz.com/SC/N/Algdat4)

**Covers & focus**
- [Lecture 1 ‚Äì Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 ‚Äì Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk) ‚Üê **highest focus**

| Topic                              | Brief description |
|-----------------------------------------------|-------------------|
| Insertion-sort lower bound via crossings      | Pack Œ±n largest at front ‚Üí many inversions; sum of squared block sizes = Œò(n¬≤) ‚áí worst-case time is Œ©(n¬≤). |
| Max{f,g} vs f+g                               | For nonnegative functions: max{f,g} = Œò(f+g); both upper/lower bound each other within constants. |
| Meaning of O/Œ©/Œò/o/œâ                          | ‚ÄúAt least O(n¬≤)‚Äù is meaningless; use Œ© for lower bounds, O for upper, Œò for tight, little-o/œâ for strict. |
| Exponential comparisons                        | Check limits/ratios: 2‚Åø‚Å∫¬π = Œò(2‚Åø); 2¬≤‚Åø is œâ(2‚Åø). |
| Set relations o(g) and œâ(g)                   | Disjoint by definition; no function can be both o(g) and œâ(g). |
| Multivariate Œò(g(n,m))                        | Tight bound up to constant on both n and m simultaneously. |
| Simple asymptotic algebra                     | Œ±n + (1‚àíŒ±)n = n; if f(n) ‚àà o(n) then n+f(n) = n¬∑(1+o(1)). |
| Log preserves Œò (additive constants)          | log(n+c) = Œò(log n); additive constants don‚Äôt change order. |
| Factorials of logs (poly-bounded?)            | ‚åàlog n‚åâ! is **not** poly-bounded; ‚åàlog log n‚åâ! **is** poly-bounded (grows subpolynomially). |
| Master Theorem parameters                     | Example: T(n)=4T(n/2)+Œò(n¬≤): a=4, b=2, n^{log_b a}=n¬≤ ‚áí Case 2. |
| Merge-sort recurrence                          | T(n)=2T(n/2)+n; critical exponent d=log_b a=log‚ÇÇ2=1. |
| D&C template                                  | DnC: split ‚Üí recurse ‚Üí combine; Master form T(n)=a¬∑T(n/b)+f(n). |


---

### > Algorithms and Data Structures ‚Äì Part 5 - TDT4120
---
*Asymptotics and relations, divide-and-conquer sorting, linear-time sorting, pivot strategies, and rooted-tree representations.*

Quiz: [Algorithms and Data Structures ‚Äì Part 5](https://www.flexiquiz.com/SC/N/Algdat5)

**Covers & focus**
- [Lecture 1 ‚Äì Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 ‚Äì Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk) ‚Üê **highest focus**
- [Lecture 4 ‚Äì Rangering i line√¶r tid](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-4---rangering-i-line%C3%A6r-tid)
- [Lecture 5 ‚Äì Rotfaste trestrukturer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-5---rotfaste-trestrukturer)

| Topic                     | Brief description |
|--------------------------------------|-------------------|
| Asymptotic relations                 | Use O/Œ©/Œò and little-o/œâ via limits/ratios (e.g., 2‚Åø vs 2^{n/2} ‚áí œâ). Rank Œò(1)‚Ä¶Œò(n‚Åø) fastest‚Üíslowest. |
| Tight bounds from mixes              | Combine Œò/O/Œ©/o terms; keep the dominant order: e.g., Œò(n‚Å¥)+O(n¬≥log n)+o(n‚Å¥) ‚áí Œò(n‚Å¥); Œò(n)+O(n¬≤)+Œ©(n¬≤) ‚áí Œò(n¬≤). |
| Divide-and-conquer sorting           | Identify binary search, merge sort, quicksort from code; master idea: split ‚Üí solve ‚Üí combine. |
| Linear-time sorting                  | Counting, radix, bucket: when keys are bounded/base-k digits or uniform in [0,1). Stability where relevant. |
| Quicksort pivots & effects           | First/last can hit Œò(n¬≤) on sorted data; randomized and median-of-three keep expected Œò(n log n); median-of-medians gives deterministic linear-time selection and balanced partitions. |
| Sorting properties table             | Fill best/avg/worst/memory for merge/quick/bubble/insertion/selection; recall stability and space needs. |
| Heaps vs BST (contrast touchpoint)   | Heaps not ordered for search; BST inorder gives sorted order. |
| Rooted-tree representations          | Left-child/right-sibling (LCRS) uses two pointers (left, right-sib) to encode arbitrary-arity trees. |


---

### > Algorithms and Data Structures ‚Äì Part 6 - TDT4120
---
*Rooted trees, heaps, BSTs, heapsort, priority queues in Prim, and spanning trees.*

Quiz: [Algorithms and Data Structures ‚Äì Part 6](https://www.flexiquiz.com/SC/N/Algdat6)

**Covers & focus**
- [Lecture 1 ‚Äì Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 5 ‚Äì Rotfaste trestrukturer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-5---rotfaste-trestrukturer) ‚Üê **highest focus**
- [Lecture 9 ‚Äì Minimale spenntr√¶r](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-9---minimale-spenntr%C3%A6r)

| Topic                  | Brief description |
|-----------------------------------|-------------------|
| Free trees ‚Üí rooted trees         | Add a designated root; defines parent/child, depth, height, subtrees. |
| Complete binary trees             | Height ‚âà ‚åälog‚ÇÇ n‚åã; nearly filled levels enable array representation. |
| Array representation of heaps     | Parent/children indices; sift-up / sift-down mechanics. |
| Max-heap invariant vs property    | Invariant: parent key ‚â• children; property: structure is complete. |
| BUILD-MAX-HEAP & MAX-HEAPIFY      | Linear-time build; heapify runs in O(log n) worst case. |
| Heaps vs BSTs                     | Heap supports fast **find-max**; BST supports fast **search by key** and sorted traversal. |
| Random BST height & balanced BSTs | Expected height for random inserts ~ O(log n); self-balancing families guarantee Œò(log n). |
| Heap operations & top-k           | INSERT / EXTRACT-MAX are Œò(log n); k-largest via heap in O(k log n) (ignoring output listing). |
| Left-child/right-sibling (LCRS)   | Tree encoding with two pointers per node to represent general trees. |
| Buckets & O(1) queries/updates    | Constant-size key universe (or bounded range) enables O(1) updates and ‚Äútop-k‚Äù by scans. |
| Inorder on BST                    | Prints keys in sorted order in Œò(n). |
| Heapsort (first iteration idea)   | Swap root with last, shrink heap, sift-down to restore heap order. |
| Prim‚Äôs PQ initialization          | BUILD-MIN-HEAP (linear) vs repeated inserts (O(n log n)); overall Prim is O(E log V). |
| Spanning trees (overview)         | Definitions, how to find them (MST by Kruskal/Prim); relation to graph connectivity. |
| Algorithmic decomposition         | Steps vs subproblems: divide-and-conquer, dynamic programming, greedy; role of induction and reductions in proofs. |
| Selection-sort with BST?          | Pros/cons of replacing scans with structures; better: use heap or proven sorting algorithms. |

---

### > Algorithms and Data Structures ‚Äì Part 7 - TDT4120
---
*Dynamic programming: ideas, design steps, rod cutting, LCS, 0/1 knapsack; graph add-ons (odd cycles, Floyd‚ÄìWarshall tweaks); hardness via reductions.*

Quiz: [Algorithms and Data Structures ‚Äì Part 7](https://www.flexiquiz.com/SC/N/Algdat7)

**Covers & focus**
- [Lecture 6 ‚Äì Dynamisk programmering](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-6---dynamisk-programmering) ‚Üê **highest focus**
- [Lecture 8 ‚Äì Traversering av grafer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-8---traversering-av-grafer)
- [Lecture 11 ‚Äì Korteste vei fra alle til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-11---korteste-vei-fra-alle-til-alle)
- [Lecture 13 ‚Äì NP-kompletthet](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-13---np-kompletthet)

| Topic                     | Brief description |
|--------------------------------------|-------------------|
| Why DP beats plain D&C               | Reuses overlapping subproblems to avoid exponential recomputation. |
| DP prerequisites                     | Optimal substructure + overlapping subproblems; bounded state space. |
| Optimal substructure                 | An optimal whole can be built from optimal subsolutions. |
| Overlapping subproblems              | Many subinstances repeat; memo/tabulation pays off. |
| DP design order                      | 1) Define state  2) Write recurrence  3) Choose top-down or bottom-up  4) Init base cases  5) Reconstruct solution (if needed). |
| Subproblem graph                     | Nodes = states; edges = dependencies used by the recurrence. |
| DP time drivers                      | Roughly (#states) √ó (work per transition). |
| Rod-cutting basics                   | Count of ways grows exponentially; naive recursion is exponential; memoized or bottom-up runs in near n¬≤. |
| Memoized vs bottom-up Cut-Rod       | Top-down with cache vs tabulation; both polynomial; bottom-up eases space tweaks; top-down explores only reachable states. |
| Reconstruction arrays                | Keep choice array (e.g., first cut) to recover the actual solution. |
| LCS state & recurrence               | State (i,j); if x·µ¢ = y‚±º then 1 + LCS(i‚àí1,j‚àí1), else max(LCS(i‚àí1,j), LCS(i,j‚àí1)). |
| 0/1 Knapsack DP                     | Time Œò(n¬∑W); pseudo-polynomial (not poly in input length). |
| Playlist exact-t (hardness)          | Reduce from subset-sum/partition to argue NP-hardness. |
| Playlist exact-t (solutions)         | DP over time (reachability), or bitset convolution; also backtrack with pruning for small n. |
| Odd cycle in directed/undirected     | Use BFS levels (undirected) or parity tracking/DFS to detect odd cycles; or reduce to bipartite test. |
| Floyd‚ÄìWarshall variants              | m-shortest lengths: keep m candidates per (i,j). Transitive closure counts: replace boolean OR/AND with integer sum/product. |
| Output recovery is ‚Äúnot trivial‚Äù     | Requires storing choices/parents; without it you only get the score. |
| Shortest path with most edges        | Layer DAG of equal-distance edges from s; within shortest-path DAG maximize edges via DP. |

  
---

### > Algorithms and Data Structures ‚Äì Part 8 - TDT4120
---
*Asymptotics, comparisons, master theorem, comparison-based sorting, reductions, and a small LP case.*

Quiz: [Algorithms and Data Structures ‚Äì Part 8](https://www.flexiquiz.com/SC/N/Algdat8)

**Covers & focus**
- [Lecture 1 ‚Äì Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 ‚Äì Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk) ‚Üê **highest focus**
- [Lecture 4 ‚Äì Rangering i line√¶r tid](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-4---rangering-i-line%C3%A6r-tid)
- [Lecture 13 ‚Äì NP-kompletthet](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-13---np-kompletthet)

| Topic                             | Brief description |
|------------------------------------|-------------------|
| Order-of-growth ranking            | Place Œò(1)‚Ä¶Œò(n‚Åø) from fastest to slowest; compare by dominant term. |
| Asymptotic comparison              | Use O/Œ©/Œò and little-o/œâ to relate two functions via limits/ratios. |
| Master theorem (template)          | Recurrences of the form T(n) = a¬∑T(n/b) + f(n); know the three main cases. |
| Combining bounds                   | Read best/worst from mixed Œ©/Œò/O expressions; identify the tight term. |
| Algebra on asymptotics             | Simplify sums like Œò(n¬≤) + O(log n) to a single tight bound. |
| Sorting (comparison-based)         | Quicksort vs mergesort: properties, ‚Äúsorting work,‚Äù PARTITION and MERGE roles. |
| K-Largest runtime idea             | Keep top-k while scanning; understand O(n¬∑k) buffer vs O(n log k) heap. |
| Reductions (X ‚â§‚Çö Y)                | Basics of polynomial-time reductions and what they imply. |
| Linear programming mini-case       | Objective and constraints formulation; interpret a small 2-variable LP. |

                                                                                                                      
---

### > Algorithms and Data Structures ‚Äì Part 9 - TDT4120
---
*Asymptotics, Master Theorem, dynamic programming (rod cutting & grid paths), DP suitability, DAG longest path, and bounded knapsack.*

Quiz: [Algorithms and Data Structures ‚Äì Part 9](https://www.flexiquiz.com/SC/N/Algdat9)

**Covers & focus**
- [Lecture 1 ‚Äì Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 ‚Äì Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk)
- [Lecture 6 ‚Äì Dynamisk programmering](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-6---dynamisk-programmering) ‚Üê **highest focus**
- [Lecture 8 ‚Äì Traversering av grafer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-8---traversering-av-grafer)
- [Lecture 13 ‚Äì NP-kompletthet](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-13---np-kompletthet)

| Topic                            | Key results & reminders (condensed) |
|-----------------------------------|-------------------------------------|
| Invertible growth rates           | Solve f(n) ‚â§ T for Œò(1), Œò(log n), Œò(n), Œò(n·µè) (fast k). Œò(c‚Åø) via n ‚âà log_c T. Not practical: Œò(n log n) (Lambert-W), Œò(n!), Œò(n‚Åø). |
| Œò-notation simplification         | n¬≥/1000 + 100n¬≤ ‚àí 100n + 3 = Œò(n¬≥). Keep highest order; drop constants. |
| Master Theorem (form)             | T(n) = a¬∑T(n/b) + f(n). Know cases 1‚Äì3 + regularity; compare f(n) with n^{log_b a}. |
| Complexity ranking (desc.)        | Œò(n!) ‚âª Œò(k‚Åø) (k>1) ‚âª Œò(n·µè) (k>1) ‚âª Œò(n log n) ‚âª Œò(n) ‚âª Œò(log n) ‚âª Œò(1). |
| Tight notation                    | Œò(¬∑) gives both upper and lower bounds (tight). |
| Simplify mixed bounds             | Œò(n¬≤)+O(n‚Å¥)+Œ©(log n) ‚Üí Œò(n¬≤).  Œò(n¬≤)+O(n¬≥)+Œ©(n) ‚Üí Œò(n¬≤). |
| When to use DP                    | Optimal substructure + overlapping subproblems + h√•ndterbar tilstandsrom. |
| Optimal substructure              | Optimal helhet bygges av optimale del-l√∏sninger (rod cutting, korteste vei i DAG). |
| Rod cutting r‚Çá (p = ‚ü®1,4,3,6,8,5,9‚ü©) | Gratis kutt: r‚Çá = 13.  Med kuttekost k=2: r‚Çá = 10. |
| Grid paths (uten/med blokker)     | Uten blokker: f·µ¢‚±º = C((i‚àí1)+(j‚àí1), i‚àí1); f‚ÇÇ,‚ÇÉ = 3.  Med blokker: f·µ¢‚±º = f·µ¢‚Çã‚ÇÅ,‚±º + f·µ¢,‚±º‚Çã‚ÇÅ; blokker ‚Üí 0; base f‚ÇÅ,‚ÇÅ = 1. |
| Segmentering av sekvens (DP)      | Del A i sammenhengende segmenter med summer i B ‚Üí naturlig prefiks-DP (overlap + optimalitet). |
| Lengste vei                       | Generell graf: lengste enkle vei er NP-hard.  I DAG: topo-rekkef√∏lge + DP ‚Üí Œò(V+E). |
| Memo vs bottom-up (DP)            | Memo (top-down) beregner kun n√•dde tilstander og passer sparsomme rom; kan gi stack-overflow. Bottom-up stabil, lett √• plass-optimalisere. |
| Top-down vs bottom-up (n√•barhet)  | Beregner kun n√•bare: **memo (top-down)**.  Mer stack-s√•rbar: **memo (top-down)**.  Ved ~5 % n√•bare: **memo** er ofte mest effektiv. |
| Bounded vs 0/1 knapsack           | Bounded (vilk√•rlig k) subsumerer 0/1 ‚Üí ingen generell algoritme som er asymptotisk raskere enn beste 0/1 for alle k. Reduksjon via bin√¶r-splitting. |


---

### > Algorithms and Data Structures ‚Äì Part 10 - TDT4120
---
*Master Theorem form, complexity ranking, heaps vs. BSTs, heapsort, dictionary ADTs (BST/balanced BST/hash), and heap/BST properties.*  

- [Lecture 1 ‚Äì Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 2 ‚Äì Datastrukturer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-2---datastrukturer)
- [Lecture 3 ‚Äì Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk)
- [Lecture 5 ‚Äì Rotfaste trestrukturer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-5---rotfaste-trestrukturer)

**Highest focus:** Lecture 5 ‚Äì Rotfaste trestrukturer

Quiz: [Algorithms and Data Structures ‚Äì Part 10](https://www.flexiquiz.com/SC/N/Algdat10)

| Topic  | Key results & reminders (condensed) |
|---|---|
| **Master Theorem ‚Äî template & cases** | Form: T(n) = a¬∑T(n/b) + f(n). Know cases 1‚Äì3 + regularity; compare f(n) to n^(log_b a). |
| **Complexity ranking (descending)** | Œò(n!) ‚âª Œò(k^n) (k>1) ‚âª Œò(n^k) (k>1) ‚âª Œò(n log n) ‚âª Œò(n) ‚âª Œò(log n) ‚âª Œò(1). |
| **Heaps vs. Binary Search Trees (BST)** | **Heap:** nearly complete shape; parent ‚â• children (max-heap). **BST:** in-order yields sorted keys; left < root < right. |
| **Heapsort ‚Äî properties** | In-place, Œò(n log n) worst-case time, not stable; build-heap then repeat extract-max + sift-down. |
| **BST insertion order & shape** | Input order affects height: best Œò(log n) (balanced), worst Œò(n) (chain); impacts tree-sort runtime. |
| **Tree-sort via BST (insert + inorder)** | Best Œò(n log n), average Œò(n log n), worst Œò(n¬≤) (degenerate BST). |
| **BST height bounds** | For n nodes: between Œ©(log n) (balanced) and O(n) (path). Without balancing, only this range is safe. |
| **Dictionary ADTs (lookup/insert/delete)** | **Hash table:** expected Œò(1) ops (uniform hashing), worst Œò(n). **Balanced BST:** Œò(log n) worst-case. **Unbalanced BST:** order-dependent. **Array:** unsorted Œò(n) find/delete; sorted has Œò(log n) find but Œò(n) insert/delete. |
| **Heap order & relations** | In a max-heap, for node x with children y, z: key(x) ‚â• key(y) and key(x) ‚â• key(z). |
| **BST minimum** | Follow left child from root until null; last visited node is the minimum. |
| **Stack via max-heap trick** | Use increasing timestamp as heap key. push: insert (ts, value). pop: extract-max. |
| **Array-as-heap view** | 1-based indexing: children at 2i and 2i+1. 0-based indexing: children at 2i+1 and 2i+2. Heapsort step: swap root with last, shrink heap, sift-down. |
| **Heap vs. BST ‚Äî central properties** | **Heap:** prioritization (fast find-max), not ordered for key search. **BST:** ordered for fast search and sorted traversal. |

---

### > Algorithms and Data Structures ‚Äì Part 11 - TDT4120
---
*Asymptotic ranking, DP suitability, greedy methods (activity selection, Huffman), MST basics (Kruskal, safe edges), shortest paths, and optimal merging.*  

Quiz: [Algorithms and Data Structures ‚Äì Part 11](https://www.flexiquiz.com/SC/N/Algdat11)

**Covers & focus**
- [Lecture 1 ‚Äì Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 6 ‚Äì Dynamisk programmering](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-6---dynamisk-programmering)
- [Lecture 7 ‚Äì Gr√•dige algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-7---gr%C3%A5dige-algoritmer) ‚Üê **highest focus**
- [Lecture 9 ‚Äì Minimale spenntr√¶r](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-9---minimale-spenntr%C3%A6r)
- [Lecture 10 ‚Äì Korteste vei fra √©n til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-10---korteste-vei-fra-%C3%A9n-til-alle)
- [Lecture 11 ‚Äì Korteste vei fra alle til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-11---korteste-vei-fra-alle-til-alle)

| Topic                      | Key results & reminders (condensed) |
|---------------------------------------|-------------------------------------|
| Complexity ranking (desc.)            | Œò(n!) ‚âª Œò(k‚Åø) (k>1) ‚âª Œò(n·µè) (k>1) ‚âª Œò(n log n) ‚âª Œò(n) ‚âª Œò(log n) ‚âª Œò(1). |
| DP suitability                         | Needs **optimal substructure** + **overlapping subproblems** and a manageable state space. |
| Greedy-choice property                 | A globally optimal solution can be built by repeatedly making a **locally** optimal choice. |
| Greedy-solvable examples               | Activity selection (by earliest finish), Huffman coding (merge two lightest), Kruskal (safe light edges across cuts). |
| Weighted interval scheduling           | Requires DP; plain activity-selection greedy is **not** optimal with weights. |
| Activity selection (second pick)       | Recursive/iterative CLRS variant: after picking the earliest finishing activity, always pick the next that **starts after** the last finish; ties broken by earliest finish. |
| Huffman coding facts                   | Prefix-free, optimal among symbol-by-symbol prefix codes; total cost = Œ£ (freq √ó depth). |
| Huffman length computation             | Build the tree (merge two minimum weights repeatedly); sum frequency √ó codeword length. |
| Kruskal‚Äôs runtime                      | Sort edges O(E log E) + union-find almost-constant amortized ‚áí **O(E log E)**. |
| Safe edge (Generic-MST)                | If A ‚äÜ some MST and (S, V‚àíS) is a cut **that respects A**, the **lightest** edge crossing it is **safe** to add to A. |
| Optimal merge of k lists               | Always merge the two **shortest** lists first (Huffman strategy) to minimize total work. |
| Shortest paths: Dijkstra vs B-Ford     | Dijkstra (greedy) for non-negative weights; Bellman‚ÄìFord handles negatives and detects negative cycles. |
| Huffman codeword lengths (bounds)      | For n ‚â• 1 symbols: min length = 1 bit (if n=1, often 1 by convention), max length ‚â§ n‚àí1 (in a chain). |

---

### > Algorithms and Data Structures ‚Äì Part 12 - TDT4120
---
*Graph representations, BFS/DFS, topological sort, shortest paths on unweighted puzzles, and strongly connected components.*

**Covers & focus**
- [Lecture 8 ‚Äì Traversering av grafer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-8---traversering-av-grafer) ‚Üê *highest focus*

| Topic                        | Brief description |
|-----------------------------------------|-------------------|
| Adjacency list vs matrix                | Space: lists Œò(n+m), matrix Œò(n¬≤). Edge-exists check: list Œò(deg(u)), matrix Œò(1). |
| Reading adjacency lists                 | Map lists to edges; be careful with direction and duplicates/self-loops. |
| Neighbor matrix (adjacency matrix)      | Build n√ón matrix M with M[i,j]=1 if edge i‚Üíj else 0. |
| BFS mechanics                           | Uses a **queue**; discovers in layers; shortest paths in unweighted graphs; time Œò(n+m). |
| DFS mechanics                           | Uses a **stack** (implicit recursion/explicit stack); timestamps, parent forest; time Œò(n+m). |
| ‚ÄúBFS with a stack?‚Äù                     | Switching to a stack turns it into **DFS** (changes order and layer guarantees). |
| Topological sorting                     | For DAGs only; via DFS postorder (reverse finish time) or Kahn‚Äôs algorithm (in-degree queue). |
| Sliding-tile puzzle (fewest moves)      | Unweighted moves ‚áí **BFS** yields fewest moves; for large spaces use A* with admissible heuristic. |
| Course prerequisites ordering           | Model as DAG; produce order via **topological sort**. |
| O(1) ancestor queries in a tree         | Do one **DFS**; store entry/exit times (Euler/in-out). A is ancestor of B iff tin[A] ‚â§ tin[B] ‚â§ tout[A]. Build Œò(n), space Œò(n). |
| BFS facts                               | Layered discovery, computes shortest-path tree from source, queue discipline, colors/levels/parents. |
| DFS facts                               | Discovery/finish times, tree/forward/back/cross edges; cycle detection; topo order from finish times. |
| Strongly connected components (SCC)     | Use **Kosaraju/Sharir** (DFS order + transpose) or **Tarjan** (lowlink). |
| SCC counts bounds                       | In a directed graph: min 1 (if strongly connected), max n (if no edges or acyclic singletons). With m ‚â• n and arbitrary digraphs, still between 1 and n. |
| Edge classification                      | Tree edges from DFS tree; in DAGs: tree, forward, cross (no back edges); in trees: only tree edges. |

---

### > Algorithms and Data Structures ‚Äì Part 13 - TDT4120
---
*Disjoint-set forests (union‚Äìfind), MST cut/cycle properties, Kruskal/Prim runtimes, and ‚Äúsafe edge‚Äù reasoning.*

**Covers & focus**
- [Lecture 9 ‚Äì Minimale spenntr√¶r](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-9---minimale-spenntr%C3%A6r) ‚Üê *highest focus*

| Topic                            | Key results & reminders (condensed) |
|---------------------------------------------|-------------------------------------|
| Disjoint-set forests (union‚Äìfind)           | `MAKE-SET`, `FIND-SET`, `UNION`. With **path compression** + **union by rank/size** ‚áí near-constant amortized time \(Œ±(n)\). Trees are conceptual; parent pointers form shallow forests. |
| All edges equal weight                       | **Any** spanning tree is minimum. #MSTs = #spanning trees of the graph (can be many). |
| Unique lightest edge                         | If an edge is **strictly** lighter than all others, it is in **every** MST (cut property). |
| Unique heaviest edge                         | Not necessarily excluded. If it lies on **any cycle**, the **cycle property** forbids it; if it‚Äôs a **bridge** (cut edge), it **must** be in the MST despite being heaviest. |
| Remove one MST edge                          | An MST minus one edge splits into two components; the remaining edges are **MSTs** for their respective vertex sets (with original weights). |
| ‚ÄúPrim with max-priority queue‚Äù               | Plainly flipping to a **max-heap** yields a **maximum** spanning tree only if the update rule mirrors Prim‚Äôs (choose heaviest safe edge). Otherwise, it‚Äôs not guaranteed minimal. |
| Wrong D&C idea for MST                       | ‚ÄúMST of left + MST of right + lightest cross edge‚Äù is **not** always optimal; local MSTs don‚Äôt compose across cuts. |
| Safe edge via cut property                   | If set \(A\) is a subset of some MST and a cut \((S, V\!\setminus\!S)\) **respects \(A\)** (no edges of \(A\) cross it), then the **lightest** edge crossing that cut is **safe** to add to \(A\). |
| ‚ÄúRespects A‚Äù (extra requirement)             | The chosen cut must **not** be crossed by any edge already in \(A\); otherwise the cut property doesn‚Äôt apply. |
| Kruskal runtime                              | Sort edges: \(O(E \log E)\). Union‚Äìfind ops: \(O(E\,Œ±(V))\). Net: **\(O(E \log E)\)**. |
| Edge classification & SCC (context)          | (For reference) Trees vs DAGs influence edge types; MST questions rely on cuts/cycles, not SCCs. |

---

### > Algorithms and Data Structures ‚Äì Part 14 - TDT4120
---
*Single-source shortest paths: DAG-SP, Dijkstra, relax/parent logic, queues & heaps (binary vs Fibonacci), and SSSP workflow details.*

Quiz: [Algorithms and Data Structures ‚Äì Part 14](https://www.flexiquiz.com/SC/N/Algdat14)

**Covers & focus**
- [Lecture 10 ‚Äì Korteste vei fra √©n til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-10---korteste-vei-fra-%C3%A9n-til-alle) ‚Üê **Highest focus**
- [Lecture 11 ‚Äì Korteste vei fra alle til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-11---korteste-vei-fra-alle-til-alle)

| Topic                          | Key results & reminders (condensed) |
|-------------------------------------------|-------------------------------------|
| SSSP basics                               | Distances init: \(d[s]=0\), others \(‚àû\). Relax updates \(d[v]\) and \(œÄ[v]\). |
| Relax operation                           | If \(d[v] > d[u] + w(u,v)\) then set \(d[v] ‚Üê d[u]+w(u,v)\), \(œÄ[v] ‚Üê u\). |
| Path optimality subpaths                  | Any subpath of a shortest path is itself shortest. |
| DAG-Shortest-Paths                        | Topologisk rekkef√∏lge; works with negative edges if no cycles; time \(Œò(V+E)\). |
| Dijkstra                                  | Non-negative edges; with binary heap \(Œò((V+E)\log V)\); with Fibonacci heap \(Œò(E + V\log V)\). |
| Fibonacci-heap advantage                  | **Decrease-key** amortized \(O(1)\) (vs \(Œò(\log n)\) in binary heap). |
| Queue discipline (BFS vs PQ)              | BFS uses **FIFO** (layered order in unweighted graphs). Dijkstra uses **min-PQ** by current distance. |
| Entering the queue/PQ                     | Standard SSSP pushes node when first discovered; further relaxations may **decrease-key**. |
| Negative edges & cycles                   | Dijkstra invalid with negative edges; New-SSSP must match Bellman‚ÄìFord guarantees. Negative cycles ‚áí ‚Äúno finite shortest path.‚Äù |
| Prim init aside (tie-in)                  | Building PQ: **BUILD-HEAP** is linear; repeated inserts \(Œò(V\log V)\). |

---

### > Algorithms and Data Structures ‚Äì Part 15 - TDT4120
---
*All-pairs shortest paths (APSP): repeated Dijkstra vs Floyd‚ÄìWarshall, predecessor matrices, transitive closure, shortest-path trees vs MSTs, and one voting-graph detour (Schulze).*

Quiz: [Algorithms and Data Structures ‚Äì Part 15](https://www.flexiquiz.com/SC/N/Algdat15)

**Covers & focus**
- [Lecture 10 ‚Äì Korteste vei fra √©n til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-10---korteste-vei-fra-%C3%A9n-til-alle)
- [Lecture 11 ‚Äì Korteste vei fra alle til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-11---korteste-vei-fra-alle-til-alle) ‚Üê *highest focus*
- [Lecture 9 ‚Äì Minimale spenntr√¶r](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-9---minimale-spenntr%C3%A6r)

| Topic                                | Key results & reminders (condensed) |
|--------------------------------------------------|-------------------------------------|
| APSP via repeated single-source runs             | Run Dijkstra from every node when all weights ‚â• 0. With binary heap: Œò(V¬∑(E log V)). With Fibonacci heap: Œò(V¬∑E + V¬≤ log V). |
| APSP pick-one fastest                            | On sparse graphs with non-negative weights, repeated Dijkstra is typically faster; on dense graphs, Floyd‚ÄìWarshall Œò(V¬≥) wins. |
| Floyd‚ÄìWarshall (FW)                              | Dynamic programming over intermediate vertices. Time Œò(V¬≥), space Œò(V¬≤). Handles negative edges; detects negative cycles (D·µ¢·µ¢ < 0). |
| Predecessor matrix œÄ                             | œÄ·µ¢‚±º stores the predecessor of j on a shortest i‚Üíj path (NIL means no path or i=j with no predecessor). Reconstruct by walking predecessors. |
| FW space-lean variant                            | Store only distance matrix (optionally a compact œÄ or ‚Äúnext‚Äù matrix). Practical version often uses O(V¬≤) space. |
| Transitive closure (reachability)                | Boolean FW: T·µè·µ¢‚±º = T·µè‚Åª¬π·µ¢‚±º ‚à® (T·µè‚Åª¬π·µ¢·µè ‚àß T·µè‚Åª¬π·µè‚±º). Replace min/+ with OR/AND. |
| Kruskal runtime refresher                        | Sort edges O(E log E) + union-find ‚âà O(E Œ±(V)) ‚áí O(E log E). |
| Shortest-path tree vs MST                        | To minimize ‚àë·µ§ dist_T(v, u) from root v, build the **shortest-path tree** (run Dijkstra from v). An MST minimizes sum of edge weights, not distances from v. |
| Dijkstra‚Äôs selection rule                        | Always extract the unseen node with **minimum tentative distance**. Decrease-key on relaxations. |
| All-pairs correctness notes                      | Subpaths of shortest paths are shortest; negative cycles ‚áí no finite APSP; FW reveals this on diagonal. |
| Schulze method (pairwise paths)                  | Treats candidates as a weighted directed graph and computes strongest paths; conceptually similar to APSP but with max-min path strengths instead of sums. |

---

### > Algorithms and Data Structures ‚Äì Part 16 - TDT4120
---
*Max-flow & min-cut, residual networks, Edmonds‚ÄìKarp, modeling tricks (production, matching, assignments), circulations with lower bounds, and a Warshall step for transitive closure.*

Quiz: [Algorithms and Data Structures ‚Äì Part 16](https://www.flexiquiz.com/SC/N/Algdat16)

**Covers & focus**
- [Lecture 12 ‚Äì Maksimal flyt](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-12---maksimal-flyt) ‚Üê **highest focus**
- [Lecture 11 ‚Äì Korteste vei fra alle til alle / Transitiv lukning (Warshall)](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-11---korteste-vei-fra-alle-til-alle)

| Topic                                            | Key results & reminders (condensed) |
|--------------------------------------------------|-------------------------------------|
| Augmenting paths & residual networks             | Use **BFS** (Edmonds‚ÄìKarp) to find shortest (by edges) augmenting path in the **residual graph**; augment by the path bottleneck. |
| Residual capacity & edge labels                  | Residual \(c^f(u,v)=c(u,v)-f(u,v)\); reverse edge has capacity \(f(u,v)\). Label ‚Äú\(a/b\)‚Äù means flow \(a\) of capacity \(b\) on \(u\!\to\!v\). |
| Ford‚ÄìFulkerson vs Edmonds‚ÄìKarp                   | F‚ÄìF is **pseudo-polynomial** (depends on capacities); E‚ÄìK picks BFS paths ‚áí **\(O(VE^2)\)** worst-case and guarantees polynomial time. |
| Max-flow value & min s‚Äìt cut                     | Flow value equals capacity of some **minimum cut** (Max-Flow Min-Cut). Identify min cut by reachable set after final residual BFS. |
| Modeling with super source/sink                  | To handle multiple sources/sinks or per-node supply limits: add **super-source** with edges to sources (cap=production), **super-sink** from sinks (cap=demand). |
| Matchings & unit capacities                      | In unit-capacity digraphs, max \(s\!\to\!t\) flow equals max number of **edge-disjoint paths**; bipartite matching reduces to max-flow. |
| Filename shortening without collisions           | Build bipartite graph: files ‚Üî candidate abbreviations; edges if abbreviation is valid/meaningful; find **maximum matching** for unique names. |
| Parity facts                                     | All capacities even ‚áí any max-flow value is **even**. With odd capacities, max-flow can be **odd or even** (no parity guarantee). |
| Edmonds‚ÄìKarp proof idea                          | Each augmentation increases some shortest-path distance; edges become ‚Äúsaturated forward/unsaturated back‚Äù only \(O(EV)\) times ‚áí \(O(VE^2)\). |
| Specialized constructions                        | ‚ÄúResearcher‚Üítask‚Üíproject‚Äù with node/edge capacities models multi-capacity assignment; feasibility via max-flow equals required totals. |
| Circulation with lower bounds                    | Reduce to max-flow: set residual capacities to \(c'(u,v)=c(u,v)-b(u,v)\), compute node **demands** \(d(v)=\sum b(in)-\sum b(out)\), connect super-source to \(v\) with \(d(v)>0\) and \(v\) to super-sink for \(d(v)<0\); feasible iff max-flow saturates all demand edges. |
| Warshall / Transitiv lukning                     | Boolean DP: \(T^{(k)}_{ij}=T^{(k-1)}_{ij}\ \lor\ (T^{(k-1)}_{ik}\land T^{(k-1)}_{kj})\). ‚ÄúApply step for vertex 4‚Äù = add edges implied via node 4 as intermediate. |


---
</details>

<br/>
<br/>
<br/>

---

**TDT4120 - Resources:**

- [VisuAlgo: Sorting](https://visualgo.net/en/sorting)
- [henrhoi/Algdat-TDT4120 (GitHub)](https://github.com/henrhoi/Algdat-TDT4120)
- [Xtrah/TDT4120 (GitHub)](https://github.com/Xtrah/TDT4120)

- [NTNU TDT4120 ‚Äî Algorithms and Data Structures (official course page)](https://www.ntnu.edu/studies/courses/TDT4120). 
- [CP-Algorithms ‚Äî Algorithms for Competitive Programming](https://cp-algorithms.com/).

<br/>
<br/>
<br/>

---


#  Model-Driven Software Engineering - TDT4250

<details>
  <summary>Click to expand</summary>

**Content:**  
- Introduction to meta-programming and meta-modeling  
- Domain-Specific Languages (DSLs), syntax and semantics  
- Model-driven development of software: transformations, code generation  
- Constraints and queries in models (e.g., OCL)  
- Component-based development and architectures  
- Software Product Lines: variability at design-time and run-time  
- Deployment, frameworks, and continuous integration of modular systems  

**Learning outcome:**  
- **Knowledge:** Understand general methods for modeling, designing, and implementing modular software; principles of model-driven development  
- **Skills:** Gain practical ability to model, design, and implement modular software using modern frameworks and model-based techniques  
- **General competence:** Be able to select appropriate methods and techniques for developing modular and model-driven software systems


### > Model-Driven Development ‚Äì Part 1 - TDT4250
---
*Dedicated to [Lecture 1 ‚Äì Introduction to MDE](https://www.flexiquiz.com/SC/N/ModelDrivenDev1).*  
*Reflects [Schmidt 2006](https://ieeexplore.ieee.org/document/1610613) and [Whittle et al. 2014](https://ieeexplore.ieee.org/document/6824042).*  

Quiz: [Model-Driven Development ‚Äì Part 1](https://www.flexiquiz.com/SC/N/ModelDrivenDev1)  

  |                                                  |                                                         |
  |--------------------------------------------------|---------------------------------------------------------|
  | Models + Transformations = Artifacts             | DSLs (SQL, HTML, Kubernetes YAML, Regex)                |
  | CASE tools vs. MDE                               | Why CASE failed in the 80s                              |
  | Metamodels: "model of models"                    | Legend/map analogy                                      |
  | DSL vs GPL                                       | Examples and differences                                |
  | Industrial use of MDE (Whittle 2014)             | Partial system generation, architecture documentation   |
  | Benefits beyond code generation                  | Explicit architectures, separation of concerns           |
  | Adoption strategies                              | Bottom-up (developer-led) vs. top-down mandates         |
  | Models ‚â† Reality                                 | Abstraction, assumptions, purpose                       |
  | Correct-by-construction                          | Contrast with construct-by-correction                   |
  | MDE in domain-focused companies                  | Automotive, printers, finance vs. consultancies         |


### > Software Product Lines ‚Äì Part 2 - TDT4250
---
*Dedicated to [Lecture 2 ‚Äì Software Product Lines](https://www.flexiquiz.com/SC/N/ModelDrivenDev2).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Software Product Lines ‚Äì Part 2](https://www.flexiquiz.com/SC/N/ModelDrivenDev2)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Definition of SPL                                | Family of products sharing core assets + controlled variability |
  | Features                                         | User-visible functionality, building blocks for variability      |
  | Domain vs Application Engineering                | For reuse (platform) vs with reuse (products)                   |
  | Adoption strategies                              | Proactive, Extractive, Reactive ‚Äì pros/cons                     |
  | Feature modeling basics                          | Mandatory, optional, OR, XOR groups                             |
  | Constraints in feature models                    | Example: MST ‚áí Undirected ‚àß Weighted                            |
  | Benefits of SPL                                  | Reduced cost, faster time-to-market, improved quality            |


### > Variability Implementation ‚Äì Part 3 - TDT4250
---
*Dedicated to [Lecture 3 ‚Äì Variability Implementation](https://www.flexiquiz.com/SC/N/ModelDrivenDev3).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Variability Implementation ‚Äì Part 3](https://www.flexiquiz.com/SC/N/ModelDrivenDev3)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Binding times                                    | Compile-time, load-time, run-time                               |
  | Language-based mechanisms                        | Parameters, design patterns, frameworks, components             |
  | Tool-driven mechanisms                           | Version-control, build systems, preprocessors                   |
  | Preprocessors                                    | Conditional compilation, disciplined vs undisciplined use        |
  | Frameworks                                       | White-box (inheritance) vs black-box (plug-ins, hot spots)       |
  | Components vs Plug-ins                           | Reuse beyond SPL vs tailored to framework                       |
  | Aspect-Oriented Programming (AOP)                | Aspects, join points, pointcuts, advice, weaving                 |
  | Virtual Separation of Concerns (VSOC)            | Views, tracing, visualization for feature separation             |
  | Granularity                                      | Fine-grained (annotations) vs coarse-grained (composition)       |
  | Evaluation criteria                              | Preplanning, traceability, separation, info hiding, uniformity   |


### > Variability with Parameters ‚Äì Classic Language-Based Mechanism - Part 4 - TDT4250
---
*Dedicated to [Lecture 4 ‚Äì Parameters](https://www.flexiquiz.com/SC/N/ModelDrivenDev4).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Variability Implementation ‚Äì Part 4](https://www.flexiquiz.com/SC/N/ModelDrivenDev4)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Core idea                                        | Variability via `if` / `switch` guarded by configuration params |
  | Sources of parameters                            | Command-line, config files, user prefs, hard-coded values, args |
  | Mapping to features                              | Typically one Boolean parameter per feature                     |
  | Pros                                             | Simple, widespread, flexible (can switch at runtime)            |
  | Cons                                             | All code shipped, runtime overhead, weak compile-time guarantees|
  | Security risk                                    | Disabled code still deployed, larger attack surface             |
  | Code quality issues                              | Globals break modularity, long arg lists = code smell           |
  | Best practice                                    | Use a **Parameter Object** to group options                     |
  | Traceability                                     | Poor; feature code scattered and tangled                        |
  | Relation to MDE                                  | Easy to adopt, but less disciplined than DSLs or composition    |


### > Domain-Specific Languages ‚Äì Modeling and Metamodeling - Part 5 - TDT4250
---
*Dedicated to [Lecture 5 ‚Äì Domain-Specific Languages](https://www.flexiquiz.com/SC/N/ModelDrivenDev5).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Variability Implementation ‚Äì Part 5](https://www.flexiquiz.com/SC/N/ModelDrivenDev5)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Core idea                                        | DSLs provide domain-optimized abstractions, reducing the problem‚Äìsolution gap |
  | GPL vs DSL                                       | GPLs are Turing complete and general; DSLs are limited but simpler and domain-focused |
  | Examples                                         | SQL, HTML, BPMN, VHDL, Simulink, Spreadsheets, Scratch          |
  | Structure of a modeling language                 | Abstract syntax (concepts), Concrete syntax (notation), Semantics (meaning) |
  | Domain analysis                                  | Identify key concepts, relations, and rules; foundation for metamodel |
  | Language design & validation                     | Formalize concepts in a metamodel; check rules with stakeholders |
  | Implementation                                   | Use frameworks like EMF/Ecore, Xtext, GMF, Sirius, Acceleo, QVT |
  | Low-code vs MDD                                  | Low-code repackages MDD ideas, marketed for rapid business apps; clearer message but less | open, more vendor lock-in |
  | Strengths                                        | Familiar notation for domain experts, concise and correct-by-construction models |
  | Weaknesses                                       | Narrow scope, may require custom tooling, risk of lock-in with closed platforms |


### > MOF & Model-Driven Architecture (MDA) - Part 6 - TDT4250  
---  
*Dedicated to [Lecture 6 ‚Äì MOF and the Model-Driven Architecture (MDA)](https://www.flexiquiz.com/SC/N/ModelDrivenDev6).*  
*Reflects OMG MDA principles and the MOF/eMOF foundations.*  

Quiz: [MOF & MDA ‚Äì Part 6](https://www.flexiquiz.com/SC/N/ModelDrivenDev6)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | **Core idea**                                    | Use models as first-class artefacts to increase portability, interoperability and automation. MDA organises specifications as models + transformations.  |
  | **Primary motivations**                          | Interoperability (vendor/tool independence) and portability (platform independence). MDA is a guideline for applying MDE practices in the SDLC.   |
  | **Key standards**                                | MOF (metamodeling / M3), UML (notation), XMI (XML interchange), QVT (model‚Üímodel transformations).  |
  | **MOF basics**                                   | MOF is an object-oriented metamodeling language (NamedElement, TypedElement, MultiplicityElement). eMOF vs cMOF; MOF is reflexive (MOF defined with MOF).  |
  | **Layering (M3‚ÜíM0)**                             | M3 = meta-metamodel (MOF), M2 = metamodel (e.g. UML/Ecore), M1 = model (domain model), M0 = runtime instances/data ‚Äî models *conformTo* their metamodel.  |
  | **PIM / PSM / CIM**                              | PIM = platform-independent model, PSM = platform-specific model, (CIM = computation-independent/business model). Transformations map PIM ‚Üí PSM (parameterisable).  |
  | **Model transformations**                        | Model‚ÜíModel (QVT) and Model‚ÜíText (code generators). Transformations can be reused, tuned and audited (security, optimisation).   |


### > Eclipse Modeling Framework (EMF) & Ecore - Part 7 - TDT4250  
---  
*Dedicated to [Lecture 7 ‚Äì Eclipse Modeling Framework (EMF)](https://www.flexiquiz.com/SC/N/ModelDrivenDev7).*  
*Based on the EMF/Ecore lecture material and examples.*  

Quiz: [EMF & Ecore ‚Äì Part 7](https://www.flexiquiz.com/SC/N/ModelDrivenDev7)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | **Core idea**                                    | EMF provides a pragmatic bridge between modelling and Java: define an Ecore metamodel, then generate Java APIs, editors and XMI persistence. :contentReference[oaicite:0]{index=0} |
  | **Ecore (role)**                                 | Ecore is Eclipse‚Äôs MOF-like metamodeling language (an EMF core metamodel). It implements MOF concepts (EClass, EAttribute, EReference, EPackage, EObject) for the Eclipse ecosystem. :contentReference[oaicite:1]{index=1} |
  | **Key metamodel elements**                       | `EPackage`, `EClass`, `EAttribute` (EDataType), `EReference` (link to EClass), `EEnum`, `EDataType`, `EOperation`, `EFactory`, `EObject`. :contentReference[oaicite:2]{index=2} |
  | **EAttribute vs EReference**                     | `EAttribute` = value-typed property (String, int, enum); `EReference` = reference to other `EObject` instances (links/associations). Multiplicity and containment are configurable. :contentReference[oaicite:3]{index=3} |
  | **Containment / composition**                    | Containment is modelled with `EReference` where `containment=true`. Containment defines the model tree (persistence/ownership) and lifecycle (contained objects saved/deleted with container). :contentReference[oaicite:4]{index=4} |
  | **Resources & ResourceSet**                      | `Resource` = unit of persistence (commonly an XMI file/URI). `ResourceSet` groups resources and resolves cross-resource references. Use `ResourceFactory` (e.g., `XMIResourceFactoryImpl`) to register serializers. :contentReference[oaicite:5]{index=5} |
  | **Code generation & runtime**                    | EMF generates a Java `interface` + `*Impl` class per `EClass`, a `Package` with metadata constants, and a `Factory` to instantiate objects; generated code is annotated with `@generated`. :contentReference[oaicite:6]{index=6} |


</details>

<br/>
<br/>
<br/>

---


#  Information Systems ‚Äì TDT4175
<details>
  <summary>Click to expand</summary>

**Content:**  
- Taxonomies and types of information systems (e.g., TPS, MIS, DSS, ERP, CRM, SCM)  
- ERP systems: functionality, selection, and introduction in organizations  
- IS strategy, digitalization, and process improvement  
- IS development methods: needs analysis, business-process modeling (as-is/to-be, e.g., BPMN), and quality evaluation of models/systems  
- Requirements engineering: elicitation techniques, modeling, validation, and documentation  
- Ethics and responsible use of information systems (privacy, security, societal impact)

**Learning outcome:**  
- **Knowledge:** Understand how business/organizational strategies relate to IS strategy; know major IS categories; grasp methods for IS deployment and improvement; understand requirements engineering approaches; recognize ethical issues in IS.  
- **Skills:** Elicit and document requirements; model and analyze business processes with BPMN; assess and communicate improvements to IS and organizational processes.  
- **General competence:** Relate IS choices to organizational goals and ethical considerations; argue for and present IS proposals grounded in stakeholder needs and process models.

### > Information Systems ‚Äì Part 1 - TDT4175
---
*Dedicated to [Lecture 1 ‚Äì Introduction to Information Systems](https://www.flexiquiz.com/SC/N/infosystems1).*  
*Reflects core TDT4175 topics: IS types, ERP, strategy & process improvement, requirements & BPMN, ethics.*

Quiz: [Information Systems ‚Äì Part 1](https://www.flexiquiz.com/SC/N/infosystems1)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **System model**                                  | Input ‚Üí Processing ‚Üí Output ‚Ü∫ Feedback; **efficiency** vs **effectiveness**; feedback as control |
| **Data vs. information**                          | Quality traits: accurate, relevant, timely, complete, simple, secure, verifiable            |
| **CBIS components**                               | Hardware, software, data/databases, telecommunications, people, procedures                  |
| **IS taxonomy**                                   | TPS, MIS, DSS, ERP, CRM, SCM‚Äîwhen to use which                                              |
| **ERP essentials**                                | Integration across functions; selection/intro strategies; change management                 |
| **MIS vs. DSS**                                   | Routine reporting vs. model-driven what-if and ad-hoc analysis                              |
| **Intranet vs. extranet**                         | Internal portal vs. controlled access for partners/suppliers                                |
| **Process modeling (BPMN)**                       | As-is/to-be, bottlenecks, KPIs; grounding improvement proposals                             |
| **Development lifecycle**                         | Investigation ‚Üí Analysis (**what**) ‚Üí Design (**how**) ‚Üí Implementation ‚Üí Maintenance       |
| **Change approaches**                             | Continuous improvement (kaizen) vs. Business Process Reengineering (BPR)                    |
| **Requirements engineering**                      | Elicitation, modeling, validation, prioritization, documentation                            |
| **Ethics & security**                             | Privacy, access control, validation, governance, societal impact                            |


### > Information Systems ‚Äì Part 2 - TDT4175
---
*Dedicated to [Lecture 2 ‚Äì Information Systems in Organizations](https://www.flexiquiz.com/SC/N/infosystems2).*  
*Reflects core TDT4175 Lesson 2 topics: value chain, SCM/CRM, org structures, change & sourcing, BPR vs CI, diffusion/infusion, applications portfolio, alignment & strategy, evaluation & roles.*

Quiz: [Information Systems ‚Äì Part 2](https://www.flexiquiz.com/SC/N/infosystems2)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Why IS in organizations**                       | IS transforms office/knowledge work; embedded in daily operations across all functions      |
| **IS role in processes**                          | Traditional: monitor/control; Contemporary: integral to input‚Äìtransform‚Äìoutput             |
| **Value chain**                                   | Upstream (inbound/storage) vs downstream (outbound/marketing/service); value-add focus     |
| **SCM basics**                                    | Plan‚Äìsource‚Äìmake‚Äìdeliver; e-marketplaces/B2B exchanges; scheduling, monitoring, control    |
| **CRM basics**                                    | Manage encounters; data from sales/surveys/web; loyalty/retention and targeted offers      |
| **Org structures**                                | Traditional‚Üíflat (empowerment); Project/Team; **Virtual** (geo/time distributed, ICT-driven)|
| **Change types**                                  | Sustaining vs **disruptive**; address resistance via involvement and change champions       |
| **Sourcing & capacity**                           | **Outsourcing** (focus core, contract risks); **On-demand**/utility computing; **Downsizing** |
| **Org learning & improvement**                    | Continuous improvement (incremental) vs **BPR** (radical, cross-functional redesign)       |
| **Diffusion vs infusion**                         | Diffusion = how wide across org; Infusion = how deep within a function; TAM: ease/usefulness |
| **Applications portfolio**                        | **Support**, **Key operational**, **Strategic**, **Future strategic**; lifecycle from idea‚Üístandard |
| **Alignment & success**                           | Tie IS to goals/processes; exec sponsorship; early user involvement; clear requirements; PM |
| **Competitive advantage**                         | Outperform industry via quality/service/cost; smart IS investment, not just higher spend   |
| **Porter‚Äôs five forces**                          | Rivalry, new entrants, substitutes, buyer power, supplier power                             |
| **Strategy levers**                               | Cost leadership, differentiation, niche focus, alter industry, new offerings, improve lines |
| **Evaluating IS**                                 | Productivity, ROI, earnings growth, market share, customer satisfaction, **TCO**            |
| **Risk awareness**                                | Large projects (e.g., ERP/e-commerce) can fail; cost > benefit if mismanaged               |
| **IS function & roles**                           | **CIO**; Operations (systems/LAN/web); Dev (analysts, programmers, agile); Support (DBA, training, helpdesk, web admin); Info service units |

### > Information Systems ‚Äì Part 3 - TDT4175
---
*Dedicated to [Lecture 3 ‚Äì Business Process Modeling & Value Framework](https://www.flexiquiz.com/SC/N/infosystems3).*  
*Reflects core TDT4175 Lesson 3 topics: process modeling goals, SEQUAL framework, quality dimensions, modeling languages/methods/tools, value framework, participatory techniques, BPMN evaluation, and big data perspectives.*

Quiz: [Information Systems ‚Äì Part 3](https://www.flexiquiz.com/SC/N/infosystems3)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Why process modeling**                         | Sense-making, communication, documentation, training, compliance, automation, improvement   |
| **SEQUAL quality dimensions**                    | Physical, empirical, semantic, pragmatic, social, deontic; balance across stakeholders/goals|
| **Modeling goals**                               | As-is vs to-be vs ought-to-be; strategic, operational, learning, standardization            |
| **Modeling practices**                           | Choice of methods, languages, tools; formal vs informal; reuse & managing practices         |
| **Knowledge maturing model**                     | Exploration ‚Üí individuation ‚Üí community ‚Üí transformation ‚Üí training/piloting ‚Üí institutionalization |
| **Managing modeling**                            | Separate roles: process owner, model manager, modeling facilitator                          |
| **Challenges & solutions**                       | Updating models, merging across org units, unintended use, sustaining ownership             |
| **Participatory techniques**                     | **STWT** (socio-technical walkthrough), **Modeling Conference** (search conference blend)   |
| **BPMN strengths**                               | Widely adopted, high representational capability, tool support, cross-org communication     |
| **BPMN weaknesses**                              | Weak resource modeling, gateway confusion, semantic perversity (e.g., data object symbol)   |
| **Notation quality principles**                  | Semiotic clarity, discriminability, semantic transparency, complexity mgmt, cognitive fit   |
| **Tool evaluation**                              | Signavio-Oryx (full palette), Bizagi, Camunda, ARIS, Visual Paradigm, Bonita ‚Äì varied support |
| **Process improvement modes**                    | Instance reuse, type-level generalization, simulation, interactive activation               |
| **Reflection & learning**                        | Reflection in/on action; collaborative reflection; tools to capture/trigger reflections     |
| **Big Data V‚Äôs**                                 | Volume, velocity, variety, veracity, visualization, value                                   |
| **Big Data + SEQUAL**                            | Volume‚Üíphysical, veracity‚Üísocial/semantic, visualization‚Üíempirical, value‚Üídeontic           |
| **Process mining**                               | Event logs ‚Üí discovery, monitoring, improvement; link BPM lifecycle to real execution       |
| **Future directions**                            | Multi-perspective modeling, top-down ‚ÄúFuture Operating Model‚Äù vs bottom-up workflows, hybrid declarative/imperative |
| **Key concerns in BPM (van der Aalst)**          | Modeling languages, enactment infrastructure, model analysis, mining, flexibility, reuse    |
| **Enduring role of modeling**                    | Even with automation/mining, models remain vital for human communication & knowledge sharing|

---

### > Information Systems ‚Äì Part 4 - TDT4175
---
*Dedicated to [Lecture 4 ‚Äì Business Process Modeling: Method & Style](https://www.flexiquiz.com/SC/N/infosystems4).*  
*Reflects core TDT4175 Lesson 4 topics: Business Process Model and Notation (BPMN) Method and Style (Chapters 1‚Äì6 of Bruce Silver), Level-1 palette, top-down modeling method, style rules for clarity and traceability, message flows and pools, end states, and practical modelling exercises.*

Quiz: [Information Systems ‚Äì Part 4](https://www.flexiquiz.com/SC/N/infosystems4)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Why BPMN Method & Style**                      | Make BPMN diagrams useful and unambiguous: combine the standard notation with a prescriptive method and concrete style rules so business and IT can share and act on models. |
| **Key standards & terms**                        | BPMN = Business Process Model and Notation; OMG = Object Management Group; XML = eXtensible Markup Language; BPMN-I = BPMN Interchange (constrained interchange rules). |
| **Core modelling goal**                          | Produce readable, correct, complete, and consistent end-to-end models that fit on one page at the top level and expand hierarchically. |
| **Level-1 palette (practical subset)**           | Start/End events, Activity / Task (VERB-NOUN labels), Subprocess / Call Activity, Sequence flow, Message flow, Pool / Lane, Gateways (Exclusive, Parallel), Data Object, Text annotation. |
| **Top-down Method (practical steps)**            | 1) Define scope (instance, start, end states). 2) Create a high-level map of major subprocesses. 3) Draw a one-page top (end-to-end) diagram. 4) Expand each collapsed subprocess on child pages. 5) Add and replicate message flows and labels for traceability. |
| **End states (practical concept)**               | Model distinct outcomes explicitly (for example ‚ÄúOrder Complete‚Äù, ‚ÄúOrder Rejected‚Äù) using separate labeled end events so downstream logic and gateways map cleanly across levels. |
| **Message flows & pools**                        | Use black-box pools for external participants; show message flows for external interactions and replicate message names/counts in child diagrams where relevant. Do not attach message flows to gateways. |
| **Naming & labeling (Style rules)**              | Activities use VERB-NOUN (for example ‚ÄúApprove Invoice‚Äù); gateways can be labelled as questions (for example ‚ÄúApproved?‚Äù) and gates should have labels or at most one unlabeled default to avoid ambiguity. |
| **Traceability rules (practical)**               | Child diagram titles must match collapsed subprocess names; message flow labels and counts must match between parent and child; subprocess child diagrams must expose labeled end events that correspond to parent-level gateways. |
| **Gateway best practice**                        | Use Exclusive (XOR) gateways for alternatives and label outgoing gates (or the gateway) to document decision conditions; use Parallel (AND) gateways for unconditional concurrency and ensure proper joins. |
| **Level-1 modelling boundaries**                 | Keep the top diagram compact (rough guideline: ~5‚Äì10 major steps). Put details in child diagrams; avoid executable-only artifacts (for example Script tasks) at Level-1. |
| **Tooling & validation**                         | Encode Style rules as tool validations where possible (flag unlabeled messages, unmatched message flows, gateways with all unlabeled gates, mismatched subprocess names) to improve consistency. |
| **Common modelling mistakes to avoid**           | Putting external partner internals in black-box pools, unlabeled gates, implicit end states, message flows attached to gateways, mixing executable task types (script/manual) in descriptive diagrams. |
| **Practical classroom exercises**                | ‚Ä¢ Workshop: convert sticky-note process to a one-page top diagram with 5‚Äì8 collapsed subprocesses; expand one subprocess and replicate message flows. ‚Ä¢ Demo: model a scheduled job with a Timer start event labeled ‚ÄúMondays at 08:00‚Äù and a customer-driven process with a Message start event labelled ‚ÄúReceive Purchase Order‚Äù. |
| **Learning outcomes for students**               | Be able to design a top-level end-to-end process map, apply the Level-1 palette correctly, name activities VERB-NOUN, create child expansions that preserve message and end-state traceability, and run basic style checks in modelling tools. |
| **Assessment pointers**                          | Evaluate: correct use of start/end events, clarity of VERB-NOUN labels, replication of message flows across levels, explicit end states that map to gateways, and compactness/readability of the top diagram. |

---

### > TDT4175 Information Systems ‚Äì Part 5
---
*SEQUAL (semiotic quality), Lean value-stream thinking, conceptual & meta-modeling, coordination choices, and the EA lens.*  

Quiz: [Information Systems ‚Äì Part 5](https://www.flexiquiz.com/SC/N/infosystems5)

Lesson: **TDT4175 ‚Äì Information Systems (Lesson 5)**

| Topic             | Brief description |
|-------------------------------|-------------------|
| SEQUAL ‚Äì semiotic quality     | The seven-layer view of model quality and the idea of fit-for-purpose across layers. |
| Value orientation             | Modeling with stakeholder value in mind (outcomes over tasks). |
| Lean value-stream thinking    | Flow, waste reduction, and continuous improvement via value-stream focus. |
| Modeling goals & uses         | Why we model: understanding, communication, analysis, compliance, and deployment. |
| Conceptual modeling           | Core domain modeling perspectives and relationships. |
| Meta-modeling (M3‚ÜíM0)         | Levels from meta-metamodel to runtime instances; language vs. model. |
| Coordination styles           | Organizational patterns for aligning or differentiating processes. |
| Value dimensions              | Time, quality, cost, flexibility, resource use, side effects, and compliance. |
| Enterprise architecture (EA)  | Portfolio and layered viewpoints linking business, applications, and technology. |
| Ways of working               | How agile/DevOps and architecture practices complement modeling and analysis. |

---

### > TDT4175 Information Systems ‚Äì Part 6
---
*Operational systems (TPS/ERP/SCM/CRM), digital channels, and decision-support layers (MIS/DSS/GSS/ESS).*  

Quiz: [Information Systems ‚Äì Part 6](https://www.flexiquiz.com/SC/N/infosystems6)

Lesson: **TDT4175 ‚Äì Information Systems (Lesson 6)**

| Topic                             | Brief description |
|-----------------------------------|-------------------|
| Operational core systems          | How organizations record and run day-to-day activities using TPS and integrated suites. |
| ERP integration                    | Enterprise-wide process and data integration across functions to reduce silos and improve data quality. |
| Supply chain planning              | Coordinating sourcing-to-delivery; aligning demand and capacity; time-phased component planning. |
| Customer relationship management  | Managing customer data and interactions across marketing, sales, and service. |
| Digital channels                   | E-commerce, mobile, and social interactions tied to back-office processes and data. |
| Public-sector digital services     | E-government interactions between citizens, businesses, and agencies. |
| Decision support layers            | From routine managerial reporting (MIS) to exploratory/what-if analysis (DSS), team support (GSS), and executive overviews (ESS). |
| KPIs and dashboards                | Periodic, structured performance views by function to monitor and steer operations. |
| Data-to-decision flow              | Turning operational data into insights for tactical and strategic decision-making. |
| Cross-cutting concerns             | Trust, privacy, security, payments, logistics/returns, and change management during adoption. |


---

### > TDT4175 Information Systems ‚Äì Part 7
---
*From integrated operations to managerial/executive decision support, knowledge management, and expert systems.*  

Quiz: [Information Systems ‚Äì Part 7](https://www.flexiquiz.com/SC/N/infosystems7)

Lesson: **TDT4175 ‚Äì Information Systems (Lesson 7)**

| Topic                             | Brief description |
|-----------------------------------|-------------------|
| Enterprise integration (ERP)      | Unifies siloed operational data (sales, inventory, finance, HR, etc.) into a single, consistent platform for cross-functional insight. |
| Programmed vs. non-programmed     | Distinguishes routine, rules-based choices from novel, uncertain decisions requiring judgment and exploration. |
| Decision Support Systems (DSS)    | Tools for ad-hoc analysis: what-if, goal-seeking, sensitivity, simulation; supports semi-structured decisions. |
| Management Information Systems    | Periodic dashboards and KPIs for monitoring, exception spotting, and operational control by middle management. |
| Executive Support Systems (ESS)   | High-level, external-aware views with drill-down for strategy, uncertainty, and exception handling at the top level. |
| Knowledge types & management      | Explicit vs. tacit knowledge; practices and systems to capture, store, share, and apply organizational know-how (KMS). |
| Expert systems & rule engines     | Codify domain expertise (knowledge base + inference) to assist non-experts with recommendations/explanations. |
| Data‚ÜíInsight pipeline             | Flow from operational capture to integrated data, reporting, analysis, and executive insight for better decisions. |
| Tool‚Äìdecision fit                 | Match system to decision type: MIS (structured), DSS (semi-structured), ESS (strategic), KMS/ES (expertise leverage). |


---

### > TDT4175 Information Systems ‚Äì Part 8
---
*Knowledge management (KM), expert/specialized IS, pervasive/mobile computing, and computer-supported cooperative work (CSCW).*  

Quiz: [Information Systems ‚Äì Part 8](https://www.flexiquiz.com/SC/N/infosystems8)

Lesson: **TDT4175 ‚Äì Information Systems (Lesson 8)**

| Topic                   | Brief description |
|------------------------------------|-------------------|
| Knowledge types                     | **Tacit** (experience, intuition) vs **Explicit** (documents, FAQs, DBs); convert and share to scale know-how. |
| KM foundations                      | People‚Äìprocess‚Äìtech: organize **create ‚Üí store ‚Üí share ‚Üí apply**; use portals, intranets, search, repositories. |
| Knowledge maps/directories          | ‚ÄúWho knows what‚Äù and where to find it; speed up discovery and reuse. |
| Expert systems (as specialized IS)  | Components: **knowledge base**, **inference engine** (forward/backward chaining), **explanation facility**, **acquisition tools**. |
| Inference & explanation             | Engine applies rules to facts to derive conclusions; explanation shows **why/how** to build trust and learning. |
| Handling uncertainty                | Techniques like fuzzy rules or confidence factors when knowledge is imprecise. |
| Immersive tech (VR/AR)              | Training, simulation, visualization where ‚Äúseeing/doing‚Äù transfers knowledge faster than reading. |
| Pervasive/mobile computing          | Devices everywhere (phones, wearables, sensors) + always-on networks ‚Üí real-time data capture and field enablement. |
| Mobile workforce enablement         | Sync from the field; faster cycle times, fewer errors, better customer service at point-of-need. |
| CSCW & remote collaboration         | Chat, shared docs, video stand-ups, task boards ‚Üí richer coordination, transparency, and quicker decisions. |
| Business impact                     | **Reach & speed**, **cost & accuracy**, **service & personalization** from embedded knowledge and connectivity. |
| Risks & design considerations       | Security/privacy, device sprawl, data quality, human-factors for small screens/in-motion contexts. |


</details>

<br/>
<br/>
<br/>


---


#  Applied Data Science ‚Äì TDT4259
<details>
  <summary>Click to expand</summary>

**Content:**  
- Lifecycle of a data science project (CRISP-DM phases: business understanding, data understanding, preparation, modeling, evaluation, deployment, monitoring)  
- Data analytics types: descriptive, diagnostic, predictive, prescriptive  
- Data sources, quality issues, preparation, and feature engineering  
- Business problem framing, value creation, and data-driven decision-making  
- Documentation practices: one-pagers and design documents (Why‚ÄìWhat‚ÄìHow)  
- Tools and techniques for data collection, exploration, modeling, and visualization  
- Group projects: solving real-world problems with open or provided datasets  
- Individual assignments: design docs for proposed data-driven solutions  
- Ethics and responsible data science (privacy, bias, fairness, societal impact)

**Learning outcome:**  
- **Knowledge:** Understand the phases of CRISP-DM; know the main types of data analytics and when to apply them; grasp principles of data preparation, quality assessment, and monitoring; recognize ethical issues in applied data science.  
- **Skills:** Frame and structure business problems into data science tasks; collect, prepare, and analyze data; evaluate models against business objectives; document and communicate solutions via one-pagers, design docs, and visualizations.  
- **General competence:** Apply data science methods to create value for organizations; work effectively in teams on real-world projects; reflect critically on ethical and societal impacts of data-driven decision-making.


### > Applied Data Science ‚Äì Part 3 - TDT4259
---
*Dedicated to [Lecture 3 ‚Äì Lifecycle of a Data Science Project](https://www.flexiquiz.com/SC/N/applieddatascience3).*  
*Reflects core TDT4259 Lesson 3 topics: CRISP-DM methodology, data analytics types, one-pagers & design docs, business understanding, data understanding, data preparation, Aneo grid loss case study, and monitoring & maintenance.*

Quiz: [Applied Data Science ‚Äì Part 3](https://www.flexiquiz.com/SC/N/applieddatascience3)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **CRISP-DM framework**                           | Business understanding ‚Üí Data understanding ‚Üí Data preparation ‚Üí Modeling ‚Üí Evaluation ‚Üí Deployment ‚Üí Monitoring |
| **Business understanding**                       | Clarify goals, scope, value, problem definition; often refine or reduce scope                |
| **Data understanding**                           | Collect, describe, explore, verify data quality; domain insights; detect anomalies/outliers  |
| **Data preparation**                             | Select, clean, construct, integrate, and format data for modeling                            |
| **Modeling**                                     | Apply statistical/ML methods; compare baselines; validate with metrics                      |
| **Evaluation**                                   | Check model results against business objectives; visualize insights                         |
| **Deployment**                                   | Translate results into actionable recommendations; plan implementation                      |
| **Monitoring & maintenance**                     | Track KPIs, retrain models, set alarms, dashboards, ensure business + technical health       |
| **Types of analytics**                           | Descriptive (what happened), Diagnostic (why), Predictive (what might happen), Prescriptive (what should we do) |
| **One-pagers**                                   | Summarize intent, desired outcome, deliverable, constraints                                 |
| **Design documents**                             | Capture Why, What, How (+ risks, infra, monitoring, cost); expensive but cheap ‚Üí avoid waste |
| **Case study: Aneo grid loss**                   | Grid loss = produced ‚Äì consumed electricity; data issues: missing/delayed values, small sets |
| **Assignment (Group)**                           | Solve a business problem with data; report + 5-min presentation                             |
| **Assignment (Individual)**                      | One-pager + ~10 page design doc; different dataset/company than group project               |

### > Applied Data Science ‚Äì Part 4 - TDT4259
---
*Dedicated to [Lecture 4 ‚Äì Data ‚Üí Features ‚Üí Algorithms](https://www.flexiquiz.com/SC/N/applieddatascience_4).*  
*Reflects core TDT4259 Lesson 4 topics: variables ‚Üí features, feature engineering, missingness & low-variance filters, scaling/normalization, PCA, supervised vs unsupervised, core algorithms (k-NN, SVM, trees, Na√Øve Bayes, neural nets), evaluation metrics, and a leakage-free pipeline.*

Quiz: [Applied Data Science ‚Äì Part 4](https://www.flexiquiz.com/SC/N/applieddatascience_4)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Variables ‚Üí Features**                         | Variables = raw columns; **features = model-ready signals** (transformed/engineered variables). |
| **Feature engineering examples**                  | `age` ‚Üí buckets, z-score; `price` ‚Üí `log1p(price)`; `signup_datetime` ‚Üí hour/day/recency; text ‚Üí TF-IDF / embeddings; image ‚Üí CNN embedding |
| **Missing Values Ratio**                         | Fraction of nulls in a column. Use it to decide drop vs impute; common thresholds: <10% simple impute, 10‚Äì30% smarter impute or flag, >30‚Äì50% drop or require justification |
| **Low-variance filter**                          | Remove near-constant features (e.g., same value >95‚Äì99% rows). Scale-sensitive ‚Äî check predictive power before dropping. |
| **Scaling / Normalization**                      | Required for distance/dot-product/variance methods (kNN, SVM, PCA, many NN optimizers). Use StandardScaler by default; MinMax/Robust/MaxAbs depending on context. Always fit scalers inside CV pipeline. |
| **PCA (Principal Component Analysis)**           | Linear dimensionality reduction: center (and usually scale) ‚Üí compute covariance or SVD ‚Üí keep top components by explained variance (e.g., 80‚Äì95%). Good for correlated numeric features; linear and less interpretable. |
| **Supervised vs Unsupervised**                   | Supervised = X + y (classification/regression). Unsupervised = X only (clustering, PCA). |
| **Core algorithms ‚Äî short**                      | **Nearest Centroid**: mean of each class; simple baseline. **k-NN**: local, distance-based; scale required. **Decision Trees**: greedy splits by impurity (Gini/entropy); no scaling required. **Random Forests / Ensembles**: robust, strong baselines. **Na√Øve Bayes**: generative, assumes conditional independence (great for text). **SVM**: max-margin; kernel trick for nonlinear boundaries; scale mandatory. **Neural Nets**: neurons = weighted sum + activation; deep nets learn hierarchical features; need data + tuning. |
| **Evaluation (regression)**                      | **MAE** (mean absolute error) ‚Äî robust; **RMSE** ‚Äî penalizes large errors more. |
| **Evaluation (classification)**                  | **Confusion matrix** (TP/FP/FN/TN). **Precision** = TP/(TP+FP). **Recall** = TP/(TP+FN). **Accuracy** = (TP+TN)/total (can mislead on imbalance). Use ROC/PR curves and choose thresholds per business needs. |
| **Likelihood vs Probability**                    | Probability: parameters fixed ‚Üí probability of data (e.g., P(x|Œ∏)). Likelihood: data fixed ‚Üí how plausible parameters are given data (used for fitting models). |
| **Practical pipeline (safe defaults)**           | 1) Train/val/test split or K-fold CV. 2) Build pipeline: impute ‚Üí encode ‚Üí scale ‚Üí (optional PCA/feature selection) ‚Üí model. 3) Tune hyperparameters inside CV. 4) Final evaluation on untouched test set. |
| **Feature/leakage warning**                       | Never compute scalers/encoders/statistics on full dataset before CV‚Äîthis leaks info. Create "missing" indicator flags when missingness may be informative. |
| **When to prefer which method**                   | Text/sparse: Na√Øve Bayes, Linear models. Mixed types/interpretability: Trees/RandomForest. Smooth numeric boundaries: SVM. Complex high-D patterns (images/audio): Deep nets. k-NN for quick, small datasets / nonparametric baseline. |
| **Quick sklearn pipeline example**                | See code block below for a leakage-free pipeline (impute + scale + PCA + SVM). |

</details>

<br/>
<br/>
<br/>

---

#  CPU-X and the human centered design process - TDT4180 #

<details>
  <summary>Click to expand</summary>

This quiz maps exactly to the CPUX-F (Foundation) / UXQB-F syllabus, covering all Foundation-level learning objectives:

*Fundamentals & Human-Centred Design*
‚Äì Concepts of usability, UX and ISO 9241-210 process steps (planning, context-of-use, requirements, design, evaluation) 
uxqb.org

- *Context of Use & User Analysis*
‚Äì Describing users, goals, tasks, environments; personas; user groups; stakeholders; as-is scenarios 
uxqb.org

- *Requirements Engineering*
‚Äì From user needs to qualitative and quantitative user requirements; human-centred quality objectives 
tecnovy

- *Information Architecture & Interaction Design*
‚Äì Navigation structures, dialogue principles (ISO 9241-110), mental models, design patterns, prototypes (low-/high-fidelity), storyboards, card sorting 
tecnovy

- *Usability Evaluation Methods*
‚Äì Usability testing (planning, moderation, pre-/post-session interviews), heuristic inspections, surveys, contextual interviews, focus groups, observations; reporting findings 
tecnovy

- *UX Professional Roles & Process Integration*
‚Äì Responsibilities in planning and managing a human-centred design project; creating deliverables; iterative refinement through usability evaluation 
uxqb.org

In other words, every question in this 40-item exam is drawn either from the public CPUX-F question set or directly from the official CPUX-F Curriculum & Glossary document, exactly as prescribed for TDT4180‚Äôs UXQB-F/CPUX-F module.

- [CPUX-F - Test 1](https://www.flexiquiz.com/SC/N/0a89b1d7-bdb1-4902-8909-ea31252500bb) - TDT4180

  |                               |                                   |
  |-------------------------------|-----------------------------------|
  | Human-centred design process  | ISO 9241-210 activities           |
  | Context of use                | Users, tasks, environments        |
  | Personas                      | Scenarios & user journey maps     |
  | User needs                    | User requirements (qual & quant)  |
  | Information architecture      | Navigation structure              |
  | Prototypes                    | Storyboards & design patterns     |
  | Dialogue principles           | Mental models & guidelines        |
  | Usability evaluation methods  | Tests, inspections, surveys       |
  | UX vs. Usability              | Satisfaction & experience factors |
  | Stakeholders                  | User groups & roles               |


- [CPUX-F - Test 2](https://www.flexiquiz.com/SC/N/6984fb3e-074c-47dd-8e7c-262bb2d584b1) - TDT4180

  |                              |                             |
  |------------------------------|-----------------------------|
  | Personas                     | Scenarios                   |
  | Human-centred requirements   | Usability measures          |
  | UX professional roles        | Design responsibilities     |
  | Usability test planning      | Test objectives             |
  | Context of use               | User requirements           |
  | Usability evaluation methods | Inspections & surveys       |
  | Human-centred design process | Activity order              |
  | Usability vs. User Experience| Satisfaction & principles   |
  | Storyboards                  | Master-apprentice principle |
  | Error tolerance              | Dialogue principles         |

</details>

<br/>
<br/>
<br/>

---