# 📚 My FlexiQuiz Learning Series 

Welcome to my curated collection of quizzes hosted on [FlexiQuiz](https://www.flexiquiz.com). These assessments are designed to test and reinforce knowledge across a variety of technical domains including **the human centered design process**, **software testing**, **Java programming**, **cryptography**,  **software security**, and **algorithms + data structures**.

Each quiz has been crafted to balance core theory with real-world application and critical thinking. Many of them are content from subjects at NTNU Trondheim, several of them are old exams questions from previous exams.

<br/>
<br/>
<br/>

---


# * CPU-X and the human centered design process - TDT4180 #

This quiz maps exactly to the CPUX-F (Foundation) / UXQB-F syllabus, covering all Foundation-level learning objectives:

*Fundamentals & Human-Centred Design*
– Concepts of usability, UX and ISO 9241-210 process steps (planning, context-of-use, requirements, design, evaluation) 
uxqb.org

- *Context of Use & User Analysis*
– Describing users, goals, tasks, environments; personas; user groups; stakeholders; as-is scenarios 
uxqb.org

- *Requirements Engineering*
– From user needs to qualitative and quantitative user requirements; human-centred quality objectives 
tecnovy

- *Information Architecture & Interaction Design*
– Navigation structures, dialogue principles (ISO 9241-110), mental models, design patterns, prototypes (low-/high-fidelity), storyboards, card sorting 
tecnovy

- *Usability Evaluation Methods*
– Usability testing (planning, moderation, pre-/post-session interviews), heuristic inspections, surveys, contextual interviews, focus groups, observations; reporting findings 
tecnovy

- *UX Professional Roles & Process Integration*
– Responsibilities in planning and managing a human-centred design project; creating deliverables; iterative refinement through usability evaluation 
uxqb.org

In other words, every question in this 40-item exam is drawn either from the public CPUX-F question set or directly from the official CPUX-F Curriculum & Glossary document, exactly as prescribed for TDT4180’s UXQB-F/CPUX-F module.

- [CPUX-F - Test 1](https://www.flexiquiz.com/SC/N/0a89b1d7-bdb1-4902-8909-ea31252500bb) - TDT4180

  |                               |                                   |
  |-------------------------------|-----------------------------------|
  | Human-centred design process  | ISO 9241-210 activities           |
  | Context of use                | Users, tasks, environments        |
  | Personas                      | Scenarios & user journey maps     |
  | User needs                    | User requirements (qual & quant)  |
  | Information architecture      | Navigation structure              |
  | Prototypes                    | Storyboards & design patterns     |
  | Dialogue principles           | Mental models & guidelines        |
  | Usability evaluation methods  | Tests, inspections, surveys       |
  | UX vs. Usability              | Satisfaction & experience factors |
  | Stakeholders                  | User groups & roles               |


- [CPUX-F - Test 2](https://www.flexiquiz.com/SC/N/6984fb3e-074c-47dd-8e7c-262bb2d584b1) - TDT4180

  |                              |                             |
  |------------------------------|-----------------------------|
  | Personas                     | Scenarios                   |
  | Human-centred requirements   | Usability measures          |
  | UX professional roles        | Design responsibilities     |
  | Usability test planning      | Test objectives             |
  | Context of use               | User requirements           |
  | Usability evaluation methods | Inspections & surveys       |
  | Human-centred design process | Activity order              |
  | Usability vs. User Experience| Satisfaction & principles   |
  | Storyboards                  | Master-apprentice principle |
  | Error tolerance              | Dialogue principles         |


<br/>
<br/>
<br/>

---


# * Software Testing and Quality Series - TDT4242

A series focused on core software testing concepts, methodologies, and best practices.
 
**Advanced Software Engineering** focuses on methods for developing reliable and complex software systems, including safety-critical and AI-assisted applications.  
**Requirements specification** – turning stakeholder needs into precise technical requirements.  
**Testing management** – planning and automating modern test processes.  
**Code quality** – using static analysis, peer review, and refactoring.  
**Verification & validation** – evaluating large-scale and AI-driven systems.  

- [Software Testing and Quality Quiz – Part 1](https://www.flexiquiz.com/SC/N/SoftwareTesting1) - TDT4242
  Covers basic testing terminology, unit testing, and manual testing fundamentals.

- [Software Testing and Quality Quiz – Part 2](https://www.flexiquiz.com/SC/N/SoftwareTesting2) - TDT4242
  Explores automated testing, integration testing, and test strategies.

- [Software Testing and Quality Quiz – Part 3](https://www.flexiquiz.com/SC/N/SoftwareTesting3) - TDT4242
  Delves into testing methodologies.

- [Software Testing and Quality Quiz – Part 4](https://www.flexiquiz.com/SC/N/SoftwareTesting4) - TDT4242
  Examines advanced topics like performance testing and test coverage metrics.

- [Software Testing and Quality Quiz – Part 5](https://www.flexiquiz.com/SC/N/SoftwareTesting5) - TDT4242
  Explores requirements engineering and test setup.

- [Software Testing and Quality Quiz – Part 6](https://www.flexiquiz.com/SC/N/SoftwareTesting6) - TDT4242
  Explores code smells, DU-coverage and Devops.

- [Software Testing and Quality Quiz – Part 7](https://www.flexiquiz.com/SC/N/SoftwareTesting7) - TDT4242
  Explores domain testing, code smells, sustainability, all-pair combinatorial tests, and Devops terms
  |                          |                                     |
  |--------------------------|-------------------------------------|
  | DevOps Metrics           | Lead Time, Cycle Time, PCA          |
  | Combinatorial Testing    | All-pairs test design               |
  | Code Quality             | Code smells & refactoring           |
  | Sustainable Applications | Efficiency, scalability, accessibility |
  | Domain Testing           | Valid vs. invalid domains           |
  | Equivalence Partitioning | Input classes for test coverage     |
  | Boundary Value Analysis  | Edge cases of input ranges          |
  | Interior vs Exterior     | Just inside/outside domain values   |
  | Numeric Boundaries       | Age, salary, numeric ranges         |
  | Non-numeric Boundaries   | Password length, registration dates |


- [Software Testing and Quality Quiz - Part 8](https://www.flexiquiz.com/SC/N/SoftwareTesting8) - TDT4242
  Explores code refactoring, testing concepts, requirements quality, requirements classification, sustainable software requirements, branch and statement coverage.

  |                       |                      |
  |-----------------------|----------------------|
  | Refactoring           | Testing techniques   |
  | Test levels           | Quality attributes   |
  | Non-functional reqs   | Sustainability       |
  | Safety                | Test cases           |
  | Requirements quality  | Traceability         |
  | Coverage              | Random testing       |
  | Statement vs branch   | Adaptive testing     |


<br/>
<br/>
<br/>

---


# * Java Programming - TDT4100

A foundational Java quiz for programmers looking to evaluate their language knowledge.

- [Java Programming Exam](https://www.flexiquiz.com/SC/N/JavaExam1)  

  |                        |                       |
  |------------------------|-----------------------|
  | Lambda expressions     | Collections           |
  | Primitive types        | Default values        |
  | Delegation             | Observer pattern      |
  | Inheritance            | Polymorphism          |
  | Design patterns        | Strategy & Factory    |
  | Streams & Matching     | Functional interfaces |
  | Encapsulation          | Object structure      |
  | Interfaces             | Abstract classes      |
  | Access modifiers       | Visibility            |
  | Method overloading     | Method overriding     |


<br/>
<br/>
<br/>

---


# * Cryptography Fundamentals - TDT4237

A concise introduction to the world of secure communications and encryption techniques.

- [Cryptography Basics Quiz](https://www.flexiquiz.com/SC/N/Cryptography1)  
  
  |                            |                           |
  |----------------------------|---------------------------|
  | Block ciphers              | Rounds in ciphers         |
  | HMAC                       | Message authentication    |
  | Elliptic Curve Cryptography| Public-key efficiency     |
  | Certification Authorities  | Trust models              |
  | Public keys                | Private keys              |
  | Authentication             | Encryption                |
  | Security models            | Cryptographic evaluation  |
  | Cryptographic techniques   | Data protection           |


<br/>
<br/>
<br/>

---


# * Software Security Series - TDT4237

A comprehensive series covering secure development practices and application-level security.

- [Software Security – Part 1](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart1) - TDT4237
  
  |                                                |                                                          |
  |------------------------------------------------|----------------------------------------------------------|
  | Recommended secure coding practices            | Symmetric encryption use in secure transmission          |
  | Asymmetric encryption (public/private keys)    | CVE vs CVSS purposes                                     |
  | Good security requirements                     | CIA Triad (Confidentiality, Integrity, Availability)     |
  | ROI of countermeasures after a data breach     | Defenses against session hijacking                       |
  | Buffer overflow defenses                       | Symmetric vs asymmetric encryption disadvantages         |
  | Django password validator implementation       | Weaknesses of password authentication & improvements     |
  | Psychological factors in social engineering    | Malicious AI attacks on recognition systems              |
  | Salt & pepper in cryptography (hashing)        | Conditions when salt fails                               |

- [Software Security – Part 2](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart2) - TDT4237

  |                                                  |                                                        |
  |--------------------------------------------------|--------------------------------------------------------|
  | Buffer overflow in C code                        | Secure coding practices (captchas, defenses)           |
  | Command injection attack                         | False cryptography statements                          |
  | Key generation best practices                    | Threat agent characteristics                           |
  | String concatenation vulnerability               | XML external entity (XXE) risk                         |
  | Storing passwords securely (hashing, salting)    | Other sensitive data exposure vulnerabilities          |
  | CVSS scoring metrics (Heartbleed case)           | Token exploitation and protection                      |
  | Insecure logging configuration                   | Secure logging and monitoring                          |
  | One-Time Pad encryption & properties             | OTP key reuse vulnerabilities                          |
  | Biba vs Bell-LaPadula models                     | Penetration testing and applications                   |
  | PoisingGPT attack steps                          | DevOps software deployment attack steps                |
  | Risk analysis threat dimensions                  | Zero-day exploit description                           |


- [Software Security – Part 3](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart3) - TDT4237

  |                                                 |                                                    |
  |-------------------------------------------------|----------------------------------------------------|
  | SQL injection vulnerability in Django code      | Secure coding fix for raw SQL                      |
  | Recommended secure practices                    | CIA triad violation                                |
  | Password policy exceptions                      | Sensitive information exposure vulnerabilities     |
  | Vulnerability prioritization (CVSS scoring)     | Common Vulnerability Scoring System (CVSS)         |
  | Common Vulnerabilities and Exposures (CVE)      | Importance of updating NuGet packages              |
  | Insecure web parameters (URL issues)            | CVE vs CVSS purposes                               |
  | Asymmetric key usage                            | Backdoors in software                              |
  | Countermeasure cost vs asset value              | Phishing/email scam defense                        |
  | Taboo traps in machine learning                 | Lawful consent under GDPR                          |
  | Logic bomb attack                               | Unicode sabotage in translation systems            |
  | Password policy enforcement in Django           | Secure logging and monitoring configuration        |


- [Software Security – Part 4](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart4) - TDT4237
  
  |                                                  |                                                       |
  |--------------------------------------------------|-------------------------------------------------------|
  | GDPR L-F-D-A-S-I-A fields                        | Business goals and business assets                    |
  | Business risks and risk dimensions               | Misuse case diagram and threat agent ranking          |
  | Attack tree for QR code misuse                   | Technical risks linked to business risks              |
  | Security requirements for technical risks        | GDPR violation discussion in crisis contexts          |
  | Machine learning use and misuse in identity      | GDPR principles (Art. 5)                              |
  | GDPR key points and legal bases                  | GDPR breach notification requirements                 |


- [Software Security - Part 5](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart5) - TDT4237

  |                                       |                                                     |
  |---------------------------------------|-----------------------------------------------------|
  | STRIDE threat categories              | Rule-Set-Based Access Control (RSBAC)               |
  | Organization-Based Access Control     | Lattice-Based Access Control (LBAC)                 |
  | Graph-Based Access Control (GBAC)     | Context-Based Access Control (CBAC)                 |
  | Bell-LaPadula model                   | Biba model                                          |
  | Clark-Wilson model                    | Brewer-Nash (Cinderella) model                      |
  | Password salting defenses             | Security by Design principles                       |
  | Bell-LaPadula vs Biba differences     | Bell-LaPadula vs Biba similarities                  |
  | Secure coding practices               | Security testing and code review                    |
  | Principle of least privilege          | Patch management strategy                           |
  | Access control mechanisms             | Common access control models                        |


<br/>
<br/>
<br/>

---


# * Web Application Security Series - TDT4237

A deep dive into common web vulnerabilities and how to prevent them.

### > Web Security – Part 1
---  
- Quiz: [Web Security – Part 1](https://www.flexiquiz.com/SC/N/WebSecPart1) - TDT4237

  |                                              |                                                     |
  |----------------------------------------------|-----------------------------------------------------|
  | Session hijacking techniques                 | Man-in-the-Middle (MITM) attack                     |
  | Cross-Site Request Forgery (CSRF)            | Cross-Site Scripting (XSS)                          |
  | XSS protection for session hijacking         | CSRF protection for session hijacking               |
  | CORS overview                                | CORS misconfiguration vulnerabilities               |
  | Server injection attack types                | SQL injection defense via parameterization          |


### > Web Security – Part 2
---  
- Quiz: [Web Security – Part 2](https://www.flexiquiz.com/SC/N/WebSecPart2) - TDT4237

  |                                      |                                                     |
  |--------------------------------------|-----------------------------------------------------|
  | File upload attacks                  | XSS mitigation techniques                           |
  | Real-world CSRF example (Twitter)    | CSRF mitigation strategies                          |
  | Session cookie protection methods    | Web server information leakage prevention           |
  | Risks of not using HTTPS             | Clickjacking prevention                             |
  | Email fraud prevention               | Cookie protection rationale                         |


### > Web Security – Part 3
---  
- Quiz: [Web Security – Part 3](https://www.flexiquiz.com/SC/N/WebSecPart3) - TDT4237

  |                                                  |                                                      |
  |--------------------------------------------------|------------------------------------------------------|
  | HTTP vs cookie-based authentication              | XSS, CSRF, and XSSI differences                      |
  | Stored XSS vs Reflected XSS                      | CSRF and Referer header limitations                  |
  | Action tokens in CSRF protection                 | Token and cookie combination defense                 |
  | XSS prevention methods                           | HTTP header vulnerability rationale                  |
  | HTTP header injection examples                   | Content-Type sniffing and XSS risks                  |
  | Reducing XSS impact                              | Recommended XSS mitigation practices                 |


### > Web Security – Part 4
---  
- Quiz: [Web Security – Part 4](https://www.flexiquiz.com/SC/N/WebSecPart4) - TDT4237
 
  |                                   |                                     |
  |-----------------------------------|-------------------------------------|
  | Web security best practices       | STRIDE threat model                 |
  | Environmental creep               | Access control models               |
  | Bell-LaPadula principles          | Bell-LaPadula rules                 |
  | SAML SSO components               | SAML use cases                      |
  | Stack overflow causes             | Call stack behavior                 |
  | Memory overflow types             | Memory safety across languages      |
  | Unsafe defaults in C/C++          | Safe defaults in C#                 |
  | Website copier tools              | HTTrack and VisualWget usage        |
  | Web debugging proxies             | Firefox Dev Tools and Fiddler       |
  | Security toolkits                 | Burp Suite, OWASP ZAP, Kali Linux   |
  | Google Dorking operators          | SSRF attack scenarios               |
  | Rainbow table protection          | Security by Design – goal           |
  | Least privilege principle         | Threat modeling importance          |


<br/>
<br/>
<br/>

---


# * Algorithms and Data Structures - TDT4120

**Content:**  
- Efficiency analysis, recursion, divide-and-conquer  
- Ordering, searching, sorting, hashing  
- Dynamic programming & greedy methods  
- Graph algorithms: shortest path, matching, spanning tree, max flow  
- Basics of complexity theory  

**Learning outcome:**  
- Recognise and apply a wide range of algorithms  
- Analyse time/space costs  
- Design new solutions when needed  
- Foundation for later AI, cyber-security, and systems courses


### > Algorithms and Data Structures – Part 1 - TDT4120
---
*NP basics, loop invariants & correctness, simple algorithms (selection/linear search), Master Theorem template, and order-of-growth ranking.*

Quiz: [Algorithms and Data Structures – Part 1](https://www.flexiquiz.com/SC/N/Algdat1)

**Covers & focus**
- [Lecture 1 – Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer) ← **høyest fokus**
- [Lecture 3 – Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk)
- [Lecture 13 – NP-kompletthet](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-13---np-kompletthet)

| Topic (overordnet)                         | Brief description |
|-------------------------------------------|-------------------|
| Why NP-complete matters                    | If any NP-complete problem has a poly-time algorithm, all problems in NP do (poly-time reductions). |
| TSP vs shortest path                       | Both are path problems; shortest path is poly-time; TSP is NP-hard/NP-complete (decision). |
| Exact vs approximate                       | When optimality is required vs “good enough” (approximation/heuristics). |
| Offline vs online                          | Entire input known up-front vs arrives over time (online algorithms, competitiveness). |
| Loop invariants (init/maint/term)          | Specify invariant, prove initialization, maintenance, termination (SUM-ARRAY, selection sort). |
| Selection sort facts                       | Maintains: A[1..i−1] sorted and ≤ remaining; runs i=1..n−1; Θ(n²) worst/avg; best is also Θ(n²). |
| Linear search                              | Average Θ(n), worst Θ(n); simple invariant over scanned prefix. |
| Master Theorem form                        | T(n) = a·T(n/b) + f(n); know the template and how to fill the blanks. |
| Two-sum in Θ(n log n)                      | Sort + two-pointer scan; outline steps and correctness idea. |
| Complexity ranking & simplification        | Rank common classes; combine Θ/O/Ω terms to a single tight order. |

---

### > Algorithms and Data Structures – Part 2 - TDT4120
---
*Asymptotic notation, sorting runtimes, greedy property, SSSP (Dijkstra vs Bellman–Ford), MST (Kruskal), and flow basics.*

Quiz: [Algorithms and Data Structures – Part 2](https://www.flexiquiz.com/SC/N/Algdat2)

**Covers & focus**
- [Lecture 1 – Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 – Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk)
- [Lecture 7 – Grådige algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-7---gr%C3%A5dige-algoritmer)
- [Lecture 9 – Minimale spenntrær](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-9---minimale-spenntr%C3%A6r)
- [Lecture 10 – Korteste vei fra én til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-10---korteste-vei-fra-%C3%A9n-til-alle) ← **høyest fokus**

| Topic (overordnet)                         | Brief description |
|-------------------------------------------|-------------------|
| Asymptotic notation                       | Θ (tight), O (upper), Ω (lower), o (strictly smaller), ω (strictly larger). Match common forms to names. |
| Combine bounds                            | O(nᵃ) + Ω(nᵇ) + Θ(nᶜ) → dominated by the largest-order term among the three. |
| Compare functions                         | Given f and g (e.g., f = n² log n + …, g = n²), decide O/Ω/Θ via limits/ratios and dominant terms. |
| Sorting runtimes                          | Insertion: best n, avg n², worst n². Merge: best/avg/worst n log n. Quick: best/avg n log n, worst n². |
| Relax(u, v, w)                            | If dist[v] > dist[u] + w(u,v), set dist[v] ← dist[u] + w and parent[v] ← u. Core of SSSP updates. |
| Dijkstra vs Bellman–Ford                  | Dijkstra (greedy) for non-negative edges; Bellman–Ford handles negatives and detects negative cycles. |
| Greedy-choice property                    | A locally optimal step can be extended to a global optimum; still need proof via cut/exchange arguments. |
| Kruskal and MST                           | MST: spanning tree with minimum total weight. Kruskal: sort edges, add safe light edges using union-find. |
| Pivot selection in Quicksort              | Pivot choice shapes balance: random keeps expected n log n; bad fixed pivots on sorted data risk n². |
| Flow vs complexity (Ford–Fulkerson)       | Pseudopolynomial due to capacity magnitudes, not NP-hardness of max-flow (max-flow is polynomial-time). |


---

### > Algorithms and Data Structures – Part 3 - TDT4120
---
*Greedy algorithms, sorting family (QS/Rand-QS/Select/Heap/Merge/Insertion), data structures (heaps vs BSTs, splay), asymptotics & NP, MST/flow basics, and the Master Theorem.*

Quiz: [Algorithms and Data Structures – Part 3](https://www.flexiquiz.com/SC/N/Algdat3)

**Covers & focus**
- [Lecture 1 – Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 – Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk)
- [Lecture 4 – Rangering i lineær tid](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-4---rangering-i-line%C3%A6r-tid)
- [Lecture 5 – Rotfaste trestrukturer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-5---rotfaste-trestrukturer)
- [Lecture 7 – Grådige algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-7---gr%C3%A5dige-algoritmer) ← **høyest fokus**
- [Lecture 9 – Minimale spenntrær](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-9---minimale-spenntr%C3%A6r)
- [Lecture 12 – Maksimal flyt](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-12---maksimal-flyt)
- [Lecture 13 – NP-kompletthet](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-13---np-kompletthet)

| Topic (overordnet)                 | Brief description |
|-----------------------------------|-------------------|
| Greedy choice property            | Locally optimal step extends to a global optimum; classic examples: activity selection, Huffman, Kruskal. |
| Heaps vs binary trees             | When heaps beat BSTs for priority access; array layout vs pointer-based trees; max-heap vs BST order. |
| Splay trees                       | Self-adjusting BSTs that move accessed nodes near the root by rotations; good amortized performance. |
| Naive recursion → improvement     | Exponential naive D&C improved by **memoization/tabulation** when optimal substructure + overlap hold. |
| Sorting family contrasts          | Quick vs Randomized-Quick; Select vs Randomized-Select; effects of using Select inside Quick. |
| Sorting facts (per algorithm)     | Best/avg/worst, stability, space for Insertion, Merge, Quick, Rand-Quick, Heap. |
| Complexity classes                | P, NP, NP-complete: verification vs search; reductions to show hardness. |
| MST basics                        | What an MST is; Prim vs Kruskal (PQ vs sort + union-find); cut and cycle properties. |
| Max-flow (Ford–Fulkerson)        | Augmenting paths, residual graphs; pseudo-polynomial due to capacity magnitude. |
| Master Theorem                    | Template T(n)=a·T(n/b)+f(n); identify case via n^{log_b a} and compare with f(n). |


---

### > Algorithms and Data Structures – Part 4 - TDT4120
---
*Asymptotic notation & properties, lower bounds via crossings, little-o/ω, Master Theorem basics, and merge-sort recurrence.*

Quiz: [Algorithms and Data Structures – Part 4](https://www.flexiquiz.com/SC/N/Algdat4)

**Covers & focus**
- [Lecture 1 – Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 – Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk) ← **høyest fokus**

| Topic (overordnet)                             | Brief description |
|-----------------------------------------------|-------------------|
| Insertion-sort lower bound via crossings      | Pack αn largest at front → many inversions; sum of squared block sizes = Θ(n²) ⇒ worst-case time is Ω(n²). |
| Max{f,g} vs f+g                               | For nonnegative functions: max{f,g} = Θ(f+g); both upper/lower bound each other within constants. |
| Meaning of O/Ω/Θ/o/ω                          | “At least O(n²)” is meaningless; use Ω for lower bounds, O for upper, Θ for tight, little-o/ω for strict. |
| Exponential comparisons                        | Check limits/ratios: 2ⁿ⁺¹ = Θ(2ⁿ); 2²ⁿ is ω(2ⁿ). |
| Set relations o(g) and ω(g)                   | Disjoint by definition; no function can be both o(g) and ω(g). |
| Multivariate Θ(g(n,m))                        | Tight bound up to constant on both n and m simultaneously. |
| Simple asymptotic algebra                     | αn + (1−α)n = n; if f(n) ∈ o(n) then n+f(n) = n·(1+o(1)). |
| Log preserves Θ (additive constants)          | log(n+c) = Θ(log n); additive constants don’t change order. |
| Factorials of logs (poly-bounded?)            | ⌈log n⌉! is **not** poly-bounded; ⌈log log n⌉! **is** poly-bounded (grows subpolynomially). |
| Master Theorem parameters                     | Example: T(n)=4T(n/2)+Θ(n²): a=4, b=2, n^{log_b a}=n² ⇒ Case 2. |
| Merge-sort recurrence                          | T(n)=2T(n/2)+n; critical exponent d=log_b a=log₂2=1. |
| D&C template                                  | DnC: split → recurse → combine; Master form T(n)=a·T(n/b)+f(n). |


---

### > Algorithms and Data Structures – Part 5 - TDT4120
---
*Asymptotics and relations, divide-and-conquer sorting, linear-time sorting, pivot strategies, and rooted-tree representations.*

Quiz: [Algorithms and Data Structures – Part 5](https://www.flexiquiz.com/SC/N/Algdat5)

**Covers & focus**
- [Lecture 1 – Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 – Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk) ← **highest focus**
- [Lecture 4 – Rangering i lineær tid](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-4---rangering-i-line%C3%A6r-tid)
- [Lecture 5 – Rotfaste trestrukturer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-5---rotfaste-trestrukturer)

| Topic (overordnet)                    | Brief description |
|--------------------------------------|-------------------|
| Asymptotic relations                 | Use O/Ω/Θ and little-o/ω via limits/ratios (e.g., 2ⁿ vs 2^{n/2} ⇒ ω). Rank Θ(1)…Θ(nⁿ) fastest→slowest. |
| Tight bounds from mixes              | Combine Θ/O/Ω/o terms; keep the dominant order: e.g., Θ(n⁴)+O(n³log n)+o(n⁴) ⇒ Θ(n⁴); Θ(n)+O(n²)+Ω(n²) ⇒ Θ(n²). |
| Divide-and-conquer sorting           | Identify binary search, merge sort, quicksort from code; master idea: split → solve → combine. |
| Linear-time sorting                  | Counting, radix, bucket: when keys are bounded/base-k digits or uniform in [0,1). Stability where relevant. |
| Quicksort pivots & effects           | First/last can hit Θ(n²) on sorted data; randomized and median-of-three keep expected Θ(n log n); median-of-medians gives deterministic linear-time selection and balanced partitions. |
| Sorting properties table             | Fill best/avg/worst/memory for merge/quick/bubble/insertion/selection; recall stability and space needs. |
| Heaps vs BST (contrast touchpoint)   | Heaps not ordered for search; BST inorder gives sorted order. |
| Rooted-tree representations          | Left-child/right-sibling (LCRS) uses two pointers (left, right-sib) to encode arbitrary-arity trees. |


---

### > Algorithms and Data Structures – Part 6 - TDT4120
---
*Rooted trees, heaps, BSTs, heapsort, priority queues in Prim, and spanning trees.*

Quiz: [Algorithms and Data Structures – Part 6](https://www.flexiquiz.com/SC/N/Algdat6)

**Covers & focus**
- [Lecture 1 – Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 5 – Rotfaste trestrukturer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-5---rotfaste-trestrukturer) ← **highest focus**
- [Lecture 9 – Minimale spenntrær](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-9---minimale-spenntr%C3%A6r)

| Topic (overordnet)                 | Brief description |
|-----------------------------------|-------------------|
| Free trees → rooted trees         | Add a designated root; defines parent/child, depth, height, subtrees. |
| Complete binary trees             | Height ≈ ⌊log₂ n⌋; nearly filled levels enable array representation. |
| Array representation of heaps     | Parent/children indices; sift-up / sift-down mechanics. |
| Max-heap invariant vs property    | Invariant: parent key ≥ children; property: structure is complete. |
| BUILD-MAX-HEAP & MAX-HEAPIFY      | Linear-time build; heapify runs in O(log n) worst case. |
| Heaps vs BSTs                     | Heap supports fast **find-max**; BST supports fast **search by key** and sorted traversal. |
| Random BST height & balanced BSTs | Expected height for random inserts ~ O(log n); self-balancing families guarantee Θ(log n). |
| Heap operations & top-k           | INSERT / EXTRACT-MAX are Θ(log n); k-largest via heap in O(k log n) (ignoring output listing). |
| Left-child/right-sibling (LCRS)   | Tree encoding with two pointers per node to represent general trees. |
| Buckets & O(1) queries/updates    | Constant-size key universe (or bounded range) enables O(1) updates and “top-k” by scans. |
| Inorder on BST                    | Prints keys in sorted order in Θ(n). |
| Heapsort (first iteration idea)   | Swap root with last, shrink heap, sift-down to restore heap order. |
| Prim’s PQ initialization          | BUILD-MIN-HEAP (linear) vs repeated inserts (O(n log n)); overall Prim is O(E log V). |
| Spanning trees (overview)         | Definitions, how to find them (MST by Kruskal/Prim); relation to graph connectivity. |
| Algorithmic decomposition         | Steps vs subproblems: divide-and-conquer, dynamic programming, greedy; role of induction and reductions in proofs. |
| Selection-sort with BST?          | Pros/cons of replacing scans with structures; better: use heap or proven sorting algorithms. |

---

### > Algorithms and Data Structures – Part 7 - TDT4120
---
*Dynamic programming: ideas, design steps, rod cutting, LCS, 0/1 knapsack; graph add-ons (odd cycles, Floyd–Warshall tweaks); hardness via reductions.*

Quiz: [Algorithms and Data Structures – Part 7](https://www.flexiquiz.com/SC/N/Algdat7)

**Covers & focus**
- [Lecture 6 – Dynamisk programmering](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-6---dynamisk-programmering) ← **highest focus**
- [Lecture 8 – Traversering av grafer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-8---traversering-av-grafer)
- [Lecture 11 – Korteste vei fra alle til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-11---korteste-vei-fra-alle-til-alle)
- [Lecture 13 – NP-kompletthet](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-13---np-kompletthet)

| Topic (overordnet)                    | Brief description |
|--------------------------------------|-------------------|
| Why DP beats plain D&C               | Reuses overlapping subproblems to avoid exponential recomputation. |
| DP prerequisites                     | Optimal substructure + overlapping subproblems; bounded state space. |
| Optimal substructure                 | An optimal whole can be built from optimal subsolutions. |
| Overlapping subproblems              | Many subinstances repeat; memo/tabulation pays off. |
| DP design order                      | 1) Define state  2) Write recurrence  3) Choose top-down or bottom-up  4) Init base cases  5) Reconstruct solution (if needed). |
| Subproblem graph                     | Nodes = states; edges = dependencies used by the recurrence. |
| DP time drivers                      | Roughly (#states) × (work per transition). |
| Rod-cutting basics                   | Count of ways grows exponentially; naive recursion is exponential; memoized or bottom-up runs in near n². |
| Memoized vs bottom-up Cut-Rod       | Top-down with cache vs tabulation; both polynomial; bottom-up eases space tweaks; top-down explores only reachable states. |
| Reconstruction arrays                | Keep choice array (e.g., first cut) to recover the actual solution. |
| LCS state & recurrence               | State (i,j); if xᵢ = yⱼ then 1 + LCS(i−1,j−1), else max(LCS(i−1,j), LCS(i,j−1)). |
| 0/1 Knapsack DP                     | Time Θ(n·W); pseudo-polynomial (not poly in input length). |
| Playlist exact-t (hardness)          | Reduce from subset-sum/partition to argue NP-hardness. |
| Playlist exact-t (solutions)         | DP over time (reachability), or bitset convolution; also backtrack with pruning for small n. |
| Odd cycle in directed/undirected     | Use BFS levels (undirected) or parity tracking/DFS to detect odd cycles; or reduce to bipartite test. |
| Floyd–Warshall variants              | m-shortest lengths: keep m candidates per (i,j). Transitive closure counts: replace boolean OR/AND with integer sum/product. |
| Output recovery is “not trivial”     | Requires storing choices/parents; without it you only get the score. |
| Shortest path with most edges        | Layer DAG of equal-distance edges from s; within shortest-path DAG maximize edges via DP. |

  
---

### > Algorithms and Data Structures – Part 8 - TDT4120
---
*Asymptotics, comparisons, master theorem, comparison-based sorting, reductions, and a small LP case.*

Quiz: [Algorithms and Data Structures – Part 8](https://www.flexiquiz.com/SC/N/Algdat8)

**Covers & focus**
- [Lecture 1 – Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 – Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk) ← **highest focus**
- [Lecture 4 – Rangering i lineær tid](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-4---rangering-i-line%C3%A6r-tid)
- [Lecture 13 – NP-kompletthet](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-13---np-kompletthet)

| Topic                             | Brief description |
|------------------------------------|-------------------|
| Order-of-growth ranking            | Place Θ(1)…Θ(nⁿ) from fastest to slowest; compare by dominant term. |
| Asymptotic comparison              | Use O/Ω/Θ and little-o/ω to relate two functions via limits/ratios. |
| Master theorem (template)          | Recurrences of the form T(n) = a·T(n/b) + f(n); know the three main cases. |
| Combining bounds                   | Read best/worst from mixed Ω/Θ/O expressions; identify the tight term. |
| Algebra on asymptotics             | Simplify sums like Θ(n²) + O(log n) to a single tight bound. |
| Sorting (comparison-based)         | Quicksort vs mergesort: properties, “sorting work,” PARTITION and MERGE roles. |
| K-Largest runtime idea             | Keep top-k while scanning; understand O(n·k) buffer vs O(n log k) heap. |
| Reductions (X ≤ₚ Y)                | Basics of polynomial-time reductions and what they imply. |
| Linear programming mini-case       | Objective and constraints formulation; interpret a small 2-variable LP. |

                                                                                                                      
---

### > Algorithms and Data Structures – Part 9 - TDT4120
---
*Asymptotics, Master Theorem, dynamic programming (rod cutting & grid paths), DP suitability, DAG longest path, and bounded knapsack.*

Quiz: [Algorithms and Data Structures – Part 9](https://www.flexiquiz.com/SC/N/Algdat9)

**Covers & focus**
- [Lecture 1 – Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 3 – Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk)
- [Lecture 6 – Dynamisk programmering](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-6---dynamisk-programmering) ← **highest focus**
- [Lecture 8 – Traversering av grafer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-8---traversering-av-grafer)
- [Lecture 13 – NP-kompletthet](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-13---np-kompletthet)

| Topic                            | Key results & reminders (condensed) |
|-----------------------------------|-------------------------------------|
| Invertible growth rates           | Solve f(n) ≤ T for Θ(1), Θ(log n), Θ(n), Θ(nᵏ) (fast k). Θ(cⁿ) via n ≈ log_c T. Not practical: Θ(n log n) (Lambert-W), Θ(n!), Θ(nⁿ). |
| Θ-notation simplification         | n³/1000 + 100n² − 100n + 3 = Θ(n³). Keep highest order; drop constants. |
| Master Theorem (form)             | T(n) = a·T(n/b) + f(n). Know cases 1–3 + regularity; compare f(n) with n^{log_b a}. |
| Complexity ranking (desc.)        | Θ(n!) ≻ Θ(kⁿ) (k>1) ≻ Θ(nᵏ) (k>1) ≻ Θ(n log n) ≻ Θ(n) ≻ Θ(log n) ≻ Θ(1). |
| Tight notation                    | Θ(·) gives both upper and lower bounds (tight). |
| Simplify mixed bounds             | Θ(n²)+O(n⁴)+Ω(log n) → Θ(n²).  Θ(n²)+O(n³)+Ω(n) → Θ(n²). |
| When to use DP                    | Optimal substructure + overlapping subproblems + håndterbar tilstandsrom. |
| Optimal substructure              | Optimal helhet bygges av optimale del-løsninger (rod cutting, korteste vei i DAG). |
| Rod cutting r₇ (p = ⟨1,4,3,6,8,5,9⟩) | Gratis kutt: r₇ = 13.  Med kuttekost k=2: r₇ = 10. |
| Grid paths (uten/med blokker)     | Uten blokker: fᵢⱼ = C((i−1)+(j−1), i−1); f₂,₃ = 3.  Med blokker: fᵢⱼ = fᵢ₋₁,ⱼ + fᵢ,ⱼ₋₁; blokker → 0; base f₁,₁ = 1. |
| Segmentering av sekvens (DP)      | Del A i sammenhengende segmenter med summer i B → naturlig prefiks-DP (overlap + optimalitet). |
| Lengste vei                       | Generell graf: lengste enkle vei er NP-hard.  I DAG: topo-rekkefølge + DP → Θ(V+E). |
| Memo vs bottom-up (DP)            | Memo (top-down) beregner kun nådde tilstander og passer sparsomme rom; kan gi stack-overflow. Bottom-up stabil, lett å plass-optimalisere. |
| Top-down vs bottom-up (nåbarhet)  | Beregner kun nåbare: **memo (top-down)**.  Mer stack-sårbar: **memo (top-down)**.  Ved ~5 % nåbare: **memo** er ofte mest effektiv. |
| Bounded vs 0/1 knapsack           | Bounded (vilkårlig k) subsumerer 0/1 → ingen generell algoritme som er asymptotisk raskere enn beste 0/1 for alle k. Reduksjon via binær-splitting. |


---

### > Algorithms and Data Structures – Part 10 - TDT4120
---
*Master Theorem form, complexity ranking, heaps vs. BSTs, heapsort, dictionary ADTs (BST/balanced BST/hash), and heap/BST properties.*  

- [Lecture 1 – Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 2 – Datastrukturer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-2---datastrukturer)
- [Lecture 3 – Splitt og hersk](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-3---splitt-og-hersk)
- [Lecture 5 – Rotfaste trestrukturer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-5---rotfaste-trestrukturer)

**Highest focus:** Lecture 5 – Rotfaste trestrukturer

Quiz: [Algorithms and Data Structures – Part 10](https://www.flexiquiz.com/SC/N/Algdat10)

| Topic  | Key results & reminders (condensed) |
|---|---|
| **Master Theorem — template & cases** | Form: T(n) = a·T(n/b) + f(n). Know cases 1–3 + regularity; compare f(n) to n^(log_b a). |
| **Complexity ranking (descending)** | Θ(n!) ≻ Θ(k^n) (k>1) ≻ Θ(n^k) (k>1) ≻ Θ(n log n) ≻ Θ(n) ≻ Θ(log n) ≻ Θ(1). |
| **Heaps vs. Binary Search Trees (BST)** | **Heap:** nearly complete shape; parent ≥ children (max-heap). **BST:** in-order yields sorted keys; left < root < right. |
| **Heapsort — properties** | In-place, Θ(n log n) worst-case time, not stable; build-heap then repeat extract-max + sift-down. |
| **BST insertion order & shape** | Input order affects height: best Θ(log n) (balanced), worst Θ(n) (chain); impacts tree-sort runtime. |
| **Tree-sort via BST (insert + inorder)** | Best Θ(n log n), average Θ(n log n), worst Θ(n²) (degenerate BST). |
| **BST height bounds** | For n nodes: between Ω(log n) (balanced) and O(n) (path). Without balancing, only this range is safe. |
| **Dictionary ADTs (lookup/insert/delete)** | **Hash table:** expected Θ(1) ops (uniform hashing), worst Θ(n). **Balanced BST:** Θ(log n) worst-case. **Unbalanced BST:** order-dependent. **Array:** unsorted Θ(n) find/delete; sorted has Θ(log n) find but Θ(n) insert/delete. |
| **Heap order & relations** | In a max-heap, for node x with children y, z: key(x) ≥ key(y) and key(x) ≥ key(z). |
| **BST minimum** | Follow left child from root until null; last visited node is the minimum. |
| **Stack via max-heap trick** | Use increasing timestamp as heap key. push: insert (ts, value). pop: extract-max. |
| **Array-as-heap view** | 1-based indexing: children at 2i and 2i+1. 0-based indexing: children at 2i+1 and 2i+2. Heapsort step: swap root with last, shrink heap, sift-down. |
| **Heap vs. BST — central properties** | **Heap:** prioritization (fast find-max), not ordered for key search. **BST:** ordered for fast search and sorted traversal. |

---

### > Algorithms and Data Structures – Part 11 - TDT4120
---
*Asymptotic ranking, DP suitability, greedy methods (activity selection, Huffman), MST basics (Kruskal, safe edges), shortest paths, and optimal merging.*  

Quiz: [Algorithms and Data Structures – Part 11](https://www.flexiquiz.com/SC/N/Algdat11)

**Covers & focus**
- [Lecture 1 – Problem og algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-1---problem-og-algoritmer)
- [Lecture 6 – Dynamisk programmering](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-6---dynamisk-programmering)
- [Lecture 7 – Grådige algoritmer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-7---gr%C3%A5dige-algoritmer) ← **highest focus**
- [Lecture 9 – Minimale spenntrær](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-9---minimale-spenntr%C3%A6r)
- [Lecture 10 – Korteste vei fra én til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-10---korteste-vei-fra-%C3%A9n-til-alle)
- [Lecture 11 – Korteste vei fra alle til alle](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#forelesning-11---korteste-vei-fra-alle-til-alle)

| Topic (overordnet)                     | Key results & reminders (condensed) |
|---------------------------------------|-------------------------------------|
| Complexity ranking (desc.)            | Θ(n!) ≻ Θ(kⁿ) (k>1) ≻ Θ(nᵏ) (k>1) ≻ Θ(n log n) ≻ Θ(n) ≻ Θ(log n) ≻ Θ(1). |
| DP suitability                         | Needs **optimal substructure** + **overlapping subproblems** and a manageable state space. |
| Greedy-choice property                 | A globally optimal solution can be built by repeatedly making a **locally** optimal choice. |
| Greedy-solvable examples               | Activity selection (by earliest finish), Huffman coding (merge two lightest), Kruskal (safe light edges across cuts). |
| Weighted interval scheduling           | Requires DP; plain activity-selection greedy is **not** optimal with weights. |
| Activity selection (second pick)       | Recursive/iterative CLRS variant: after picking the earliest finishing activity, always pick the next that **starts after** the last finish; ties broken by earliest finish. |
| Huffman coding facts                   | Prefix-free, optimal among symbol-by-symbol prefix codes; total cost = Σ (freq × depth). |
| Huffman length computation             | Build the tree (merge two minimum weights repeatedly); sum frequency × codeword length. |
| Kruskal’s runtime                      | Sort edges O(E log E) + union-find almost-constant amortized ⇒ **O(E log E)**. |
| Safe edge (Generic-MST)                | If A ⊆ some MST and (S, V−S) is a cut **that respects A**, the **lightest** edge crossing it is **safe** to add to A. |
| Optimal merge of k lists               | Always merge the two **shortest** lists first (Huffman strategy) to minimize total work. |
| Shortest paths: Dijkstra vs B-Ford     | Dijkstra (greedy) for non-negative weights; Bellman–Ford handles negatives and detects negative cycles. |
| Huffman codeword lengths (bounds)      | For n ≥ 1 symbols: min length = 1 bit (if n=1, often 1 by convention), max length ≤ n−1 (in a chain). |


---

<br/>
<br/>
<br/>

---

**TDT4120 - Resources:**

- [VisuAlgo: Sorting](https://visualgo.net/en/sorting)
- [henrhoi/Algdat-TDT4120 (GitHub)](https://github.com/henrhoi/Algdat-TDT4120)
- [Xtrah/TDT4120 (GitHub)](https://github.com/Xtrah/TDT4120)

- [NTNU TDT4120 — Algorithms and Data Structures (official course page)](https://www.ntnu.edu/studies/courses/TDT4120). 
- [CP-Algorithms — Algorithms for Competitive Programming](https://cp-algorithms.com/).


<br/>
<br/>
<br/>

---


# * Model-Driven Software Engineering - TDT4250

**Content:**  
- Introduction to meta-programming and meta-modeling  
- Domain-Specific Languages (DSLs), syntax and semantics  
- Model-driven development of software: transformations, code generation  
- Constraints and queries in models (e.g., OCL)  
- Component-based development and architectures  
- Software Product Lines: variability at design-time and run-time  
- Deployment, frameworks, and continuous integration of modular systems  

**Learning outcome:**  
- **Knowledge:** Understand general methods for modeling, designing, and implementing modular software; principles of model-driven development  
- **Skills:** Gain practical ability to model, design, and implement modular software using modern frameworks and model-based techniques  
- **General competence:** Be able to select appropriate methods and techniques for developing modular and model-driven software systems


### > Model-Driven Development – Part 1 - TDT4250
---
*Dedicated to [Lecture 1 – Introduction to MDE](https://www.flexiquiz.com/SC/N/ModelDrivenDev1).*  
*Reflects [Schmidt 2006](https://ieeexplore.ieee.org/document/1610613) and [Whittle et al. 2014](https://ieeexplore.ieee.org/document/6824042).*  

Quiz: [Model-Driven Development – Part 1](https://www.flexiquiz.com/SC/N/ModelDrivenDev1)  

  |                                                  |                                                         |
  |--------------------------------------------------|---------------------------------------------------------|
  | Models + Transformations = Artifacts             | DSLs (SQL, HTML, Kubernetes YAML, Regex)                |
  | CASE tools vs. MDE                               | Why CASE failed in the 80s                              |
  | Metamodels: "model of models"                    | Legend/map analogy                                      |
  | DSL vs GPL                                       | Examples and differences                                |
  | Industrial use of MDE (Whittle 2014)             | Partial system generation, architecture documentation   |
  | Benefits beyond code generation                  | Explicit architectures, separation of concerns           |
  | Adoption strategies                              | Bottom-up (developer-led) vs. top-down mandates         |
  | Models ≠ Reality                                 | Abstraction, assumptions, purpose                       |
  | Correct-by-construction                          | Contrast with construct-by-correction                   |
  | MDE in domain-focused companies                  | Automotive, printers, finance vs. consultancies         |


### > Software Product Lines – Part 2 - TDT4250
---
*Dedicated to [Lecture 2 – Software Product Lines](https://www.flexiquiz.com/SC/N/ModelDrivenDev2).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Software Product Lines – Part 2](https://www.flexiquiz.com/SC/N/ModelDrivenDev2)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Definition of SPL                                | Family of products sharing core assets + controlled variability |
  | Features                                         | User-visible functionality, building blocks for variability      |
  | Domain vs Application Engineering                | For reuse (platform) vs with reuse (products)                   |
  | Adoption strategies                              | Proactive, Extractive, Reactive – pros/cons                     |
  | Feature modeling basics                          | Mandatory, optional, OR, XOR groups                             |
  | Constraints in feature models                    | Example: MST ⇒ Undirected ∧ Weighted                            |
  | Benefits of SPL                                  | Reduced cost, faster time-to-market, improved quality            |


### > Variability Implementation – Part 3 - TDT4250
---
*Dedicated to [Lecture 3 – Variability Implementation](https://www.flexiquiz.com/SC/N/ModelDrivenDev3).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Variability Implementation – Part 3](https://www.flexiquiz.com/SC/N/ModelDrivenDev3)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Binding times                                    | Compile-time, load-time, run-time                               |
  | Language-based mechanisms                        | Parameters, design patterns, frameworks, components             |
  | Tool-driven mechanisms                           | Version-control, build systems, preprocessors                   |
  | Preprocessors                                    | Conditional compilation, disciplined vs undisciplined use        |
  | Frameworks                                       | White-box (inheritance) vs black-box (plug-ins, hot spots)       |
  | Components vs Plug-ins                           | Reuse beyond SPL vs tailored to framework                       |
  | Aspect-Oriented Programming (AOP)                | Aspects, join points, pointcuts, advice, weaving                 |
  | Virtual Separation of Concerns (VSOC)            | Views, tracing, visualization for feature separation             |
  | Granularity                                      | Fine-grained (annotations) vs coarse-grained (composition)       |
  | Evaluation criteria                              | Preplanning, traceability, separation, info hiding, uniformity   |


### > Variability with Parameters – Classic Language-Based Mechanism - Part 4 - TDT4250
---
*Dedicated to [Lecture 4 – Parameters](https://www.flexiquiz.com/SC/N/ModelDrivenDev4).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Variability Implementation – Part 4](https://www.flexiquiz.com/SC/N/ModelDrivenDev4)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Core idea                                        | Variability via `if` / `switch` guarded by configuration params |
  | Sources of parameters                            | Command-line, config files, user prefs, hard-coded values, args |
  | Mapping to features                              | Typically one Boolean parameter per feature                     |
  | Pros                                             | Simple, widespread, flexible (can switch at runtime)            |
  | Cons                                             | All code shipped, runtime overhead, weak compile-time guarantees|
  | Security risk                                    | Disabled code still deployed, larger attack surface             |
  | Code quality issues                              | Globals break modularity, long arg lists = code smell           |
  | Best practice                                    | Use a **Parameter Object** to group options                     |
  | Traceability                                     | Poor; feature code scattered and tangled                        |
  | Relation to MDE                                  | Easy to adopt, but less disciplined than DSLs or composition    |


### > Domain-Specific Languages – Modeling and Metamodeling - Part 5 - TDT4250
---
*Dedicated to [Lecture 5 – Domain-Specific Languages](https://www.flexiquiz.com/SC/N/ModelDrivenDev5).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Variability Implementation – Part 5](https://www.flexiquiz.com/SC/N/ModelDrivenDev5)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Core idea                                        | DSLs provide domain-optimized abstractions, reducing the problem–solution gap |
  | GPL vs DSL                                       | GPLs are Turing complete and general; DSLs are limited but simpler and domain-focused |
  | Examples                                         | SQL, HTML, BPMN, VHDL, Simulink, Spreadsheets, Scratch          |
  | Structure of a modeling language                 | Abstract syntax (concepts), Concrete syntax (notation), Semantics (meaning) |
  | Domain analysis                                  | Identify key concepts, relations, and rules; foundation for metamodel |
  | Language design & validation                     | Formalize concepts in a metamodel; check rules with stakeholders |
  | Implementation                                   | Use frameworks like EMF/Ecore, Xtext, GMF, Sirius, Acceleo, QVT |
  | Low-code vs MDD                                  | Low-code repackages MDD ideas, marketed for rapid business apps; clearer message but less | open, more vendor lock-in |
  | Strengths                                        | Familiar notation for domain experts, concise and correct-by-construction models |
  | Weaknesses                                       | Narrow scope, may require custom tooling, risk of lock-in with closed platforms |


### > MOF & Model-Driven Architecture (MDA) - Part 6 - TDT4250  
---  
*Dedicated to [Lecture 6 – MOF and the Model-Driven Architecture (MDA)](https://www.flexiquiz.com/SC/N/ModelDrivenDev6).*  
*Reflects OMG MDA principles and the MOF/eMOF foundations.*  

Quiz: [MOF & MDA – Part 6](https://www.flexiquiz.com/SC/N/ModelDrivenDev6)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | **Core idea**                                    | Use models as first-class artefacts to increase portability, interoperability and automation. MDA organises specifications as models + transformations.  |
  | **Primary motivations**                          | Interoperability (vendor/tool independence) and portability (platform independence). MDA is a guideline for applying MDE practices in the SDLC.   |
  | **Key standards**                                | MOF (metamodeling / M3), UML (notation), XMI (XML interchange), QVT (model→model transformations).  |
  | **MOF basics**                                   | MOF is an object-oriented metamodeling language (NamedElement, TypedElement, MultiplicityElement). eMOF vs cMOF; MOF is reflexive (MOF defined with MOF).  |
  | **Layering (M3→M0)**                             | M3 = meta-metamodel (MOF), M2 = metamodel (e.g. UML/Ecore), M1 = model (domain model), M0 = runtime instances/data — models *conformTo* their metamodel.  |
  | **PIM / PSM / CIM**                              | PIM = platform-independent model, PSM = platform-specific model, (CIM = computation-independent/business model). Transformations map PIM → PSM (parameterisable).  |
  | **Model transformations**                        | Model→Model (QVT) and Model→Text (code generators). Transformations can be reused, tuned and audited (security, optimisation).   |


### > Eclipse Modeling Framework (EMF) & Ecore - Part 7 - TDT4250  
---  
*Dedicated to [Lecture 7 – Eclipse Modeling Framework (EMF)](https://www.flexiquiz.com/SC/N/ModelDrivenDev7).*  
*Based on the EMF/Ecore lecture material and examples.*  

Quiz: [EMF & Ecore – Part 7](https://www.flexiquiz.com/SC/N/ModelDrivenDev7)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | **Core idea**                                    | EMF provides a pragmatic bridge between modelling and Java: define an Ecore metamodel, then generate Java APIs, editors and XMI persistence. :contentReference[oaicite:0]{index=0} |
  | **Ecore (role)**                                 | Ecore is Eclipse’s MOF-like metamodeling language (an EMF core metamodel). It implements MOF concepts (EClass, EAttribute, EReference, EPackage, EObject) for the Eclipse ecosystem. :contentReference[oaicite:1]{index=1} |
  | **Key metamodel elements**                       | `EPackage`, `EClass`, `EAttribute` (EDataType), `EReference` (link to EClass), `EEnum`, `EDataType`, `EOperation`, `EFactory`, `EObject`. :contentReference[oaicite:2]{index=2} |
  | **EAttribute vs EReference**                     | `EAttribute` = value-typed property (String, int, enum); `EReference` = reference to other `EObject` instances (links/associations). Multiplicity and containment are configurable. :contentReference[oaicite:3]{index=3} |
  | **Containment / composition**                    | Containment is modelled with `EReference` where `containment=true`. Containment defines the model tree (persistence/ownership) and lifecycle (contained objects saved/deleted with container). :contentReference[oaicite:4]{index=4} |
  | **Resources & ResourceSet**                      | `Resource` = unit of persistence (commonly an XMI file/URI). `ResourceSet` groups resources and resolves cross-resource references. Use `ResourceFactory` (e.g., `XMIResourceFactoryImpl`) to register serializers. :contentReference[oaicite:5]{index=5} |
  | **Code generation & runtime**                    | EMF generates a Java `interface` + `*Impl` class per `EClass`, a `Package` with metadata constants, and a `Factory` to instantiate objects; generated code is annotated with `@generated`. :contentReference[oaicite:6]{index=6} |


<br/>
<br/>
<br/>

---


# * Information Systems – TDT4175

**Content:**  
- Taxonomies and types of information systems (e.g., TPS, MIS, DSS, ERP, CRM, SCM)  
- ERP systems: functionality, selection, and introduction in organizations  
- IS strategy, digitalization, and process improvement  
- IS development methods: needs analysis, business-process modeling (as-is/to-be, e.g., BPMN), and quality evaluation of models/systems  
- Requirements engineering: elicitation techniques, modeling, validation, and documentation  
- Ethics and responsible use of information systems (privacy, security, societal impact)

**Learning outcome:**  
- **Knowledge:** Understand how business/organizational strategies relate to IS strategy; know major IS categories; grasp methods for IS deployment and improvement; understand requirements engineering approaches; recognize ethical issues in IS.  
- **Skills:** Elicit and document requirements; model and analyze business processes with BPMN; assess and communicate improvements to IS and organizational processes.  
- **General competence:** Relate IS choices to organizational goals and ethical considerations; argue for and present IS proposals grounded in stakeholder needs and process models.

### > Information Systems – Part 1 - TDT4175
---
*Dedicated to [Lecture 1 – Introduction to Information Systems](https://www.flexiquiz.com/SC/N/infosystems1).*  
*Reflects core TDT4175 topics: IS types, ERP, strategy & process improvement, requirements & BPMN, ethics.*

Quiz: [Information Systems – Part 1](https://www.flexiquiz.com/SC/N/infosystems1)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **System model**                                  | Input → Processing → Output ↺ Feedback; **efficiency** vs **effectiveness**; feedback as control |
| **Data vs. information**                          | Quality traits: accurate, relevant, timely, complete, simple, secure, verifiable            |
| **CBIS components**                               | Hardware, software, data/databases, telecommunications, people, procedures                  |
| **IS taxonomy**                                   | TPS, MIS, DSS, ERP, CRM, SCM—when to use which                                              |
| **ERP essentials**                                | Integration across functions; selection/intro strategies; change management                 |
| **MIS vs. DSS**                                   | Routine reporting vs. model-driven what-if and ad-hoc analysis                              |
| **Intranet vs. extranet**                         | Internal portal vs. controlled access for partners/suppliers                                |
| **Process modeling (BPMN)**                       | As-is/to-be, bottlenecks, KPIs; grounding improvement proposals                             |
| **Development lifecycle**                         | Investigation → Analysis (**what**) → Design (**how**) → Implementation → Maintenance       |
| **Change approaches**                             | Continuous improvement (kaizen) vs. Business Process Reengineering (BPR)                    |
| **Requirements engineering**                      | Elicitation, modeling, validation, prioritization, documentation                            |
| **Ethics & security**                             | Privacy, access control, validation, governance, societal impact                            |


### > Information Systems – Part 2 - TDT4175
---
*Dedicated to [Lecture 2 – Information Systems in Organizations](https://www.flexiquiz.com/SC/N/infosystems2).*  
*Reflects core TDT4175 Lesson 2 topics: value chain, SCM/CRM, org structures, change & sourcing, BPR vs CI, diffusion/infusion, applications portfolio, alignment & strategy, evaluation & roles.*

Quiz: [Information Systems – Part 2](https://www.flexiquiz.com/SC/N/infosystems2)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Why IS in organizations**                       | IS transforms office/knowledge work; embedded in daily operations across all functions      |
| **IS role in processes**                          | Traditional: monitor/control; Contemporary: integral to input–transform–output             |
| **Value chain**                                   | Upstream (inbound/storage) vs downstream (outbound/marketing/service); value-add focus     |
| **SCM basics**                                    | Plan–source–make–deliver; e-marketplaces/B2B exchanges; scheduling, monitoring, control    |
| **CRM basics**                                    | Manage encounters; data from sales/surveys/web; loyalty/retention and targeted offers      |
| **Org structures**                                | Traditional→flat (empowerment); Project/Team; **Virtual** (geo/time distributed, ICT-driven)|
| **Change types**                                  | Sustaining vs **disruptive**; address resistance via involvement and change champions       |
| **Sourcing & capacity**                           | **Outsourcing** (focus core, contract risks); **On-demand**/utility computing; **Downsizing** |
| **Org learning & improvement**                    | Continuous improvement (incremental) vs **BPR** (radical, cross-functional redesign)       |
| **Diffusion vs infusion**                         | Diffusion = how wide across org; Infusion = how deep within a function; TAM: ease/usefulness |
| **Applications portfolio**                        | **Support**, **Key operational**, **Strategic**, **Future strategic**; lifecycle from idea→standard |
| **Alignment & success**                           | Tie IS to goals/processes; exec sponsorship; early user involvement; clear requirements; PM |
| **Competitive advantage**                         | Outperform industry via quality/service/cost; smart IS investment, not just higher spend   |
| **Porter’s five forces**                          | Rivalry, new entrants, substitutes, buyer power, supplier power                             |
| **Strategy levers**                               | Cost leadership, differentiation, niche focus, alter industry, new offerings, improve lines |
| **Evaluating IS**                                 | Productivity, ROI, earnings growth, market share, customer satisfaction, **TCO**            |
| **Risk awareness**                                | Large projects (e.g., ERP/e-commerce) can fail; cost > benefit if mismanaged               |
| **IS function & roles**                           | **CIO**; Operations (systems/LAN/web); Dev (analysts, programmers, agile); Support (DBA, training, helpdesk, web admin); Info service units |

### > Information Systems – Part 3 - TDT4175
---
*Dedicated to [Lecture 3 – Business Process Modeling & Value Framework](https://www.flexiquiz.com/SC/N/infosystems3).*  
*Reflects core TDT4175 Lesson 3 topics: process modeling goals, SEQUAL framework, quality dimensions, modeling languages/methods/tools, value framework, participatory techniques, BPMN evaluation, and big data perspectives.*

Quiz: [Information Systems – Part 3](https://www.flexiquiz.com/SC/N/infosystems3)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Why process modeling**                         | Sense-making, communication, documentation, training, compliance, automation, improvement   |
| **SEQUAL quality dimensions**                    | Physical, empirical, semantic, pragmatic, social, deontic; balance across stakeholders/goals|
| **Modeling goals**                               | As-is vs to-be vs ought-to-be; strategic, operational, learning, standardization            |
| **Modeling practices**                           | Choice of methods, languages, tools; formal vs informal; reuse & managing practices         |
| **Knowledge maturing model**                     | Exploration → individuation → community → transformation → training/piloting → institutionalization |
| **Managing modeling**                            | Separate roles: process owner, model manager, modeling facilitator                          |
| **Challenges & solutions**                       | Updating models, merging across org units, unintended use, sustaining ownership             |
| **Participatory techniques**                     | **STWT** (socio-technical walkthrough), **Modeling Conference** (search conference blend)   |
| **BPMN strengths**                               | Widely adopted, high representational capability, tool support, cross-org communication     |
| **BPMN weaknesses**                              | Weak resource modeling, gateway confusion, semantic perversity (e.g., data object symbol)   |
| **Notation quality principles**                  | Semiotic clarity, discriminability, semantic transparency, complexity mgmt, cognitive fit   |
| **Tool evaluation**                              | Signavio-Oryx (full palette), Bizagi, Camunda, ARIS, Visual Paradigm, Bonita – varied support |
| **Process improvement modes**                    | Instance reuse, type-level generalization, simulation, interactive activation               |
| **Reflection & learning**                        | Reflection in/on action; collaborative reflection; tools to capture/trigger reflections     |
| **Big Data V’s**                                 | Volume, velocity, variety, veracity, visualization, value                                   |
| **Big Data + SEQUAL**                            | Volume→physical, veracity→social/semantic, visualization→empirical, value→deontic           |
| **Process mining**                               | Event logs → discovery, monitoring, improvement; link BPM lifecycle to real execution       |
| **Future directions**                            | Multi-perspective modeling, top-down “Future Operating Model” vs bottom-up workflows, hybrid declarative/imperative |
| **Key concerns in BPM (van der Aalst)**          | Modeling languages, enactment infrastructure, model analysis, mining, flexibility, reuse    |
| **Enduring role of modeling**                    | Even with automation/mining, models remain vital for human communication & knowledge sharing|

---

### > Information Systems – Part 4 - TDT4175
---
*Dedicated to [Lecture 4 – Business Process Modeling: Method & Style](https://www.flexiquiz.com/SC/N/infosystems4).*  
*Reflects core TDT4175 Lesson 4 topics: Business Process Model and Notation (BPMN) Method and Style (Chapters 1–6 of Bruce Silver), Level-1 palette, top-down modeling method, style rules for clarity and traceability, message flows and pools, end states, and practical modelling exercises.*

Quiz: [Information Systems – Part 4](https://www.flexiquiz.com/SC/N/infosystems4)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Why BPMN Method & Style**                      | Make BPMN diagrams useful and unambiguous: combine the standard notation with a prescriptive method and concrete style rules so business and IT can share and act on models. |
| **Key standards & terms**                        | BPMN = Business Process Model and Notation; OMG = Object Management Group; XML = eXtensible Markup Language; BPMN-I = BPMN Interchange (constrained interchange rules). |
| **Core modelling goal**                          | Produce readable, correct, complete, and consistent end-to-end models that fit on one page at the top level and expand hierarchically. |
| **Level-1 palette (practical subset)**           | Start/End events, Activity / Task (VERB-NOUN labels), Subprocess / Call Activity, Sequence flow, Message flow, Pool / Lane, Gateways (Exclusive, Parallel), Data Object, Text annotation. |
| **Top-down Method (practical steps)**            | 1) Define scope (instance, start, end states). 2) Create a high-level map of major subprocesses. 3) Draw a one-page top (end-to-end) diagram. 4) Expand each collapsed subprocess on child pages. 5) Add and replicate message flows and labels for traceability. |
| **End states (practical concept)**               | Model distinct outcomes explicitly (for example “Order Complete”, “Order Rejected”) using separate labeled end events so downstream logic and gateways map cleanly across levels. |
| **Message flows & pools**                        | Use black-box pools for external participants; show message flows for external interactions and replicate message names/counts in child diagrams where relevant. Do not attach message flows to gateways. |
| **Naming & labeling (Style rules)**              | Activities use VERB-NOUN (for example “Approve Invoice”); gateways can be labelled as questions (for example “Approved?”) and gates should have labels or at most one unlabeled default to avoid ambiguity. |
| **Traceability rules (practical)**               | Child diagram titles must match collapsed subprocess names; message flow labels and counts must match between parent and child; subprocess child diagrams must expose labeled end events that correspond to parent-level gateways. |
| **Gateway best practice**                        | Use Exclusive (XOR) gateways for alternatives and label outgoing gates (or the gateway) to document decision conditions; use Parallel (AND) gateways for unconditional concurrency and ensure proper joins. |
| **Level-1 modelling boundaries**                 | Keep the top diagram compact (rough guideline: ~5–10 major steps). Put details in child diagrams; avoid executable-only artifacts (for example Script tasks) at Level-1. |
| **Tooling & validation**                         | Encode Style rules as tool validations where possible (flag unlabeled messages, unmatched message flows, gateways with all unlabeled gates, mismatched subprocess names) to improve consistency. |
| **Common modelling mistakes to avoid**           | Putting external partner internals in black-box pools, unlabeled gates, implicit end states, message flows attached to gateways, mixing executable task types (script/manual) in descriptive diagrams. |
| **Practical classroom exercises**                | • Workshop: convert sticky-note process to a one-page top diagram with 5–8 collapsed subprocesses; expand one subprocess and replicate message flows. • Demo: model a scheduled job with a Timer start event labeled “Mondays at 08:00” and a customer-driven process with a Message start event labelled “Receive Purchase Order”. |
| **Learning outcomes for students**               | Be able to design a top-level end-to-end process map, apply the Level-1 palette correctly, name activities VERB-NOUN, create child expansions that preserve message and end-state traceability, and run basic style checks in modelling tools. |
| **Assessment pointers**                          | Evaluate: correct use of start/end events, clarity of VERB-NOUN labels, replication of message flows across levels, explicit end states that map to gateways, and compactness/readability of the top diagram. |

---

### > TDT4175 Information Systems – Part 5
---
*SEQUAL (semiotic quality), Lean value-stream thinking, conceptual & meta-modeling, coordination choices, and the EA lens.*  

Quiz: [Information Systems – Part 5](https://www.flexiquiz.com/SC/N/infosystems5)

Lesson: **TDT4175 – Information Systems (Lesson 5)**

| Topic             | Brief description |
|-------------------------------|-------------------|
| SEQUAL – semiotic quality     | The seven-layer view of model quality and the idea of fit-for-purpose across layers. |
| Value orientation             | Modeling with stakeholder value in mind (outcomes over tasks). |
| Lean value-stream thinking    | Flow, waste reduction, and continuous improvement via value-stream focus. |
| Modeling goals & uses         | Why we model: understanding, communication, analysis, compliance, and deployment. |
| Conceptual modeling           | Core domain modeling perspectives and relationships. |
| Meta-modeling (M3→M0)         | Levels from meta-metamodel to runtime instances; language vs. model. |
| Coordination styles           | Organizational patterns for aligning or differentiating processes. |
| Value dimensions              | Time, quality, cost, flexibility, resource use, side effects, and compliance. |
| Enterprise architecture (EA)  | Portfolio and layered viewpoints linking business, applications, and technology. |
| Ways of working               | How agile/DevOps and architecture practices complement modeling and analysis. |

---

### > TDT4175 Information Systems – Part 6
---
*Operational systems (TPS/ERP/SCM/CRM), digital channels, and decision-support layers (MIS/DSS/GSS/ESS).*  

Quiz: [Information Systems – Part 6](https://www.flexiquiz.com/SC/N/infosystems6)

Lesson: **TDT4175 – Information Systems (Lesson 6)**

| Topic                             | Brief description |
|-----------------------------------|-------------------|
| Operational core systems          | How organizations record and run day-to-day activities using TPS and integrated suites. |
| ERP integration                    | Enterprise-wide process and data integration across functions to reduce silos and improve data quality. |
| Supply chain planning              | Coordinating sourcing-to-delivery; aligning demand and capacity; time-phased component planning. |
| Customer relationship management  | Managing customer data and interactions across marketing, sales, and service. |
| Digital channels                   | E-commerce, mobile, and social interactions tied to back-office processes and data. |
| Public-sector digital services     | E-government interactions between citizens, businesses, and agencies. |
| Decision support layers            | From routine managerial reporting (MIS) to exploratory/what-if analysis (DSS), team support (GSS), and executive overviews (ESS). |
| KPIs and dashboards                | Periodic, structured performance views by function to monitor and steer operations. |
| Data-to-decision flow              | Turning operational data into insights for tactical and strategic decision-making. |
| Cross-cutting concerns             | Trust, privacy, security, payments, logistics/returns, and change management during adoption. |


---

### > TDT4175 Information Systems – Part 7
---
*From integrated operations to managerial/executive decision support, knowledge management, and expert systems.*  

Quiz: [Information Systems – Part 7](https://www.flexiquiz.com/SC/N/infosystems7)

Lesson: **TDT4175 – Information Systems (Lesson 7)**

| Topic                             | Brief description |
|-----------------------------------|-------------------|
| Enterprise integration (ERP)      | Unifies siloed operational data (sales, inventory, finance, HR, etc.) into a single, consistent platform for cross-functional insight. |
| Programmed vs. non-programmed     | Distinguishes routine, rules-based choices from novel, uncertain decisions requiring judgment and exploration. |
| Decision Support Systems (DSS)    | Tools for ad-hoc analysis: what-if, goal-seeking, sensitivity, simulation; supports semi-structured decisions. |
| Management Information Systems    | Periodic dashboards and KPIs for monitoring, exception spotting, and operational control by middle management. |
| Executive Support Systems (ESS)   | High-level, external-aware views with drill-down for strategy, uncertainty, and exception handling at the top level. |
| Knowledge types & management      | Explicit vs. tacit knowledge; practices and systems to capture, store, share, and apply organizational know-how (KMS). |
| Expert systems & rule engines     | Codify domain expertise (knowledge base + inference) to assist non-experts with recommendations/explanations. |
| Data→Insight pipeline             | Flow from operational capture to integrated data, reporting, analysis, and executive insight for better decisions. |
| Tool–decision fit                 | Match system to decision type: MIS (structured), DSS (semi-structured), ESS (strategic), KMS/ES (expertise leverage). |


---

### > TDT4175 Information Systems – Part 8
---
*Knowledge management (KM), expert/specialized IS, pervasive/mobile computing, and computer-supported cooperative work (CSCW).*  

Quiz: [Information Systems – Part 8](https://www.flexiquiz.com/SC/N/infosystems8)

Lesson: **TDT4175 – Information Systems (Lesson 8)**

| Topic                   | Brief description |
|------------------------------------|-------------------|
| Knowledge types                     | **Tacit** (experience, intuition) vs **Explicit** (documents, FAQs, DBs); convert and share to scale know-how. |
| KM foundations                      | People–process–tech: organize **create → store → share → apply**; use portals, intranets, search, repositories. |
| Knowledge maps/directories          | “Who knows what” and where to find it; speed up discovery and reuse. |
| Expert systems (as specialized IS)  | Components: **knowledge base**, **inference engine** (forward/backward chaining), **explanation facility**, **acquisition tools**. |
| Inference & explanation             | Engine applies rules to facts to derive conclusions; explanation shows **why/how** to build trust and learning. |
| Handling uncertainty                | Techniques like fuzzy rules or confidence factors when knowledge is imprecise. |
| Immersive tech (VR/AR)              | Training, simulation, visualization where “seeing/doing” transfers knowledge faster than reading. |
| Pervasive/mobile computing          | Devices everywhere (phones, wearables, sensors) + always-on networks → real-time data capture and field enablement. |
| Mobile workforce enablement         | Sync from the field; faster cycle times, fewer errors, better customer service at point-of-need. |
| CSCW & remote collaboration         | Chat, shared docs, video stand-ups, task boards → richer coordination, transparency, and quicker decisions. |
| Business impact                     | **Reach & speed**, **cost & accuracy**, **service & personalization** from embedded knowledge and connectivity. |
| Risks & design considerations       | Security/privacy, device sprawl, data quality, human-factors for small screens/in-motion contexts. |


<br/>
<br/>
<br/>

---

# * Applied Data Science – TDT4259

**Content:**  
- Lifecycle of a data science project (CRISP-DM phases: business understanding, data understanding, preparation, modeling, evaluation, deployment, monitoring)  
- Data analytics types: descriptive, diagnostic, predictive, prescriptive  
- Data sources, quality issues, preparation, and feature engineering  
- Business problem framing, value creation, and data-driven decision-making  
- Documentation practices: one-pagers and design documents (Why–What–How)  
- Tools and techniques for data collection, exploration, modeling, and visualization  
- Group projects: solving real-world problems with open or provided datasets  
- Individual assignments: design docs for proposed data-driven solutions  
- Ethics and responsible data science (privacy, bias, fairness, societal impact)

**Learning outcome:**  
- **Knowledge:** Understand the phases of CRISP-DM; know the main types of data analytics and when to apply them; grasp principles of data preparation, quality assessment, and monitoring; recognize ethical issues in applied data science.  
- **Skills:** Frame and structure business problems into data science tasks; collect, prepare, and analyze data; evaluate models against business objectives; document and communicate solutions via one-pagers, design docs, and visualizations.  
- **General competence:** Apply data science methods to create value for organizations; work effectively in teams on real-world projects; reflect critically on ethical and societal impacts of data-driven decision-making.


### > Applied Data Science – Part 3 - TDT4259
---
*Dedicated to [Lecture 3 – Lifecycle of a Data Science Project](https://www.flexiquiz.com/SC/N/applieddatascience3).*  
*Reflects core TDT4259 Lesson 3 topics: CRISP-DM methodology, data analytics types, one-pagers & design docs, business understanding, data understanding, data preparation, Aneo grid loss case study, and monitoring & maintenance.*

Quiz: [Applied Data Science – Part 3](https://www.flexiquiz.com/SC/N/applieddatascience3)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **CRISP-DM framework**                           | Business understanding → Data understanding → Data preparation → Modeling → Evaluation → Deployment → Monitoring |
| **Business understanding**                       | Clarify goals, scope, value, problem definition; often refine or reduce scope                |
| **Data understanding**                           | Collect, describe, explore, verify data quality; domain insights; detect anomalies/outliers  |
| **Data preparation**                             | Select, clean, construct, integrate, and format data for modeling                            |
| **Modeling**                                     | Apply statistical/ML methods; compare baselines; validate with metrics                      |
| **Evaluation**                                   | Check model results against business objectives; visualize insights                         |
| **Deployment**                                   | Translate results into actionable recommendations; plan implementation                      |
| **Monitoring & maintenance**                     | Track KPIs, retrain models, set alarms, dashboards, ensure business + technical health       |
| **Types of analytics**                           | Descriptive (what happened), Diagnostic (why), Predictive (what might happen), Prescriptive (what should we do) |
| **One-pagers**                                   | Summarize intent, desired outcome, deliverable, constraints                                 |
| **Design documents**                             | Capture Why, What, How (+ risks, infra, monitoring, cost); expensive but cheap → avoid waste |
| **Case study: Aneo grid loss**                   | Grid loss = produced – consumed electricity; data issues: missing/delayed values, small sets |
| **Assignment (Group)**                           | Solve a business problem with data; report + 5-min presentation                             |
| **Assignment (Individual)**                      | One-pager + ~10 page design doc; different dataset/company than group project               |

### > Applied Data Science – Part 4 - TDT4259
---
*Dedicated to [Lecture 4 – Data → Features → Algorithms](https://www.flexiquiz.com/SC/N/applieddatascience_4).*  
*Reflects core TDT4259 Lesson 4 topics: variables → features, feature engineering, missingness & low-variance filters, scaling/normalization, PCA, supervised vs unsupervised, core algorithms (k-NN, SVM, trees, Naïve Bayes, neural nets), evaluation metrics, and a leakage-free pipeline.*

Quiz: [Applied Data Science – Part 4](https://www.flexiquiz.com/SC/N/applieddatascience_4)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Variables → Features**                         | Variables = raw columns; **features = model-ready signals** (transformed/engineered variables). |
| **Feature engineering examples**                  | `age` → buckets, z-score; `price` → `log1p(price)`; `signup_datetime` → hour/day/recency; text → TF-IDF / embeddings; image → CNN embedding |
| **Missing Values Ratio**                         | Fraction of nulls in a column. Use it to decide drop vs impute; common thresholds: <10% simple impute, 10–30% smarter impute or flag, >30–50% drop or require justification |
| **Low-variance filter**                          | Remove near-constant features (e.g., same value >95–99% rows). Scale-sensitive — check predictive power before dropping. |
| **Scaling / Normalization**                      | Required for distance/dot-product/variance methods (kNN, SVM, PCA, many NN optimizers). Use StandardScaler by default; MinMax/Robust/MaxAbs depending on context. Always fit scalers inside CV pipeline. |
| **PCA (Principal Component Analysis)**           | Linear dimensionality reduction: center (and usually scale) → compute covariance or SVD → keep top components by explained variance (e.g., 80–95%). Good for correlated numeric features; linear and less interpretable. |
| **Supervised vs Unsupervised**                   | Supervised = X + y (classification/regression). Unsupervised = X only (clustering, PCA). |
| **Core algorithms — short**                      | **Nearest Centroid**: mean of each class; simple baseline. **k-NN**: local, distance-based; scale required. **Decision Trees**: greedy splits by impurity (Gini/entropy); no scaling required. **Random Forests / Ensembles**: robust, strong baselines. **Naïve Bayes**: generative, assumes conditional independence (great for text). **SVM**: max-margin; kernel trick for nonlinear boundaries; scale mandatory. **Neural Nets**: neurons = weighted sum + activation; deep nets learn hierarchical features; need data + tuning. |
| **Evaluation (regression)**                      | **MAE** (mean absolute error) — robust; **RMSE** — penalizes large errors more. |
| **Evaluation (classification)**                  | **Confusion matrix** (TP/FP/FN/TN). **Precision** = TP/(TP+FP). **Recall** = TP/(TP+FN). **Accuracy** = (TP+TN)/total (can mislead on imbalance). Use ROC/PR curves and choose thresholds per business needs. |
| **Likelihood vs Probability**                    | Probability: parameters fixed → probability of data (e.g., P(x|θ)). Likelihood: data fixed → how plausible parameters are given data (used for fitting models). |
| **Practical pipeline (safe defaults)**           | 1) Train/val/test split or K-fold CV. 2) Build pipeline: impute → encode → scale → (optional PCA/feature selection) → model. 3) Tune hyperparameters inside CV. 4) Final evaluation on untouched test set. |
| **Feature/leakage warning**                       | Never compute scalers/encoders/statistics on full dataset before CV—this leaks info. Create "missing" indicator flags when missingness may be informative. |
| **When to prefer which method**                   | Text/sparse: Naïve Bayes, Linear models. Mixed types/interpretability: Trees/RandomForest. Smooth numeric boundaries: SVM. Complex high-D patterns (images/audio): Deep nets. k-NN for quick, small datasets / nonparametric baseline. |
| **Quick sklearn pipeline example**                | See code block below for a leakage-free pipeline (impute + scale + PCA + SVM). |