# 📚 My FlexiQuiz Learning Series 

Welcome to my curated collection of quizzes hosted on [FlexiQuiz](https://www.flexiquiz.com). These assessments are designed to test and reinforce knowledge across a variety of technical domains including **the human centered design process**, **software testing**, **Java programming**, **cryptography**,  **software security**, and **algorithms + data structures**.

Each quiz has been crafted to balance core theory with real-world application and critical thinking. Many of them are content from subjects at NTNU Trondheim, several of them are old exams questions from previous exams.

---

# * CPU-X and the human centered design process - TDT4180 #

This quiz maps exactly to the CPUX-F (Foundation) / UXQB-F syllabus, covering all Foundation-level learning objectives:

*Fundamentals & Human-Centred Design*
– Concepts of usability, UX and ISO 9241-210 process steps (planning, context-of-use, requirements, design, evaluation) 
uxqb.org

- *Context of Use & User Analysis*
– Describing users, goals, tasks, environments; personas; user groups; stakeholders; as-is scenarios 
uxqb.org

- *Requirements Engineering*
– From user needs to qualitative and quantitative user requirements; human-centred quality objectives 
tecnovy

- *Information Architecture & Interaction Design*
– Navigation structures, dialogue principles (ISO 9241-110), mental models, design patterns, prototypes (low-/high-fidelity), storyboards, card sorting 
tecnovy

- *Usability Evaluation Methods*
– Usability testing (planning, moderation, pre-/post-session interviews), heuristic inspections, surveys, contextual interviews, focus groups, observations; reporting findings 
tecnovy

- *UX Professional Roles & Process Integration*
– Responsibilities in planning and managing a human-centred design project; creating deliverables; iterative refinement through usability evaluation 
uxqb.org

In other words, every question in this 40-item exam is drawn either from the public CPUX-F question set or directly from the official CPUX-F Curriculum & Glossary document, exactly as prescribed for TDT4180’s UXQB-F/CPUX-F module.

- [CPUX-F - Test 1](https://www.flexiquiz.com/SC/N/0a89b1d7-bdb1-4902-8909-ea31252500bb) - TDT4180

  |                               |                                   |
  |-------------------------------|-----------------------------------|
  | Human-centred design process  | ISO 9241-210 activities           |
  | Context of use                | Users, tasks, environments        |
  | Personas                      | Scenarios & user journey maps     |
  | User needs                    | User requirements (qual & quant)  |
  | Information architecture      | Navigation structure              |
  | Prototypes                    | Storyboards & design patterns     |
  | Dialogue principles           | Mental models & guidelines        |
  | Usability evaluation methods  | Tests, inspections, surveys       |
  | UX vs. Usability              | Satisfaction & experience factors |
  | Stakeholders                  | User groups & roles               |


- [CPUX-F - Test 2](https://www.flexiquiz.com/SC/N/6984fb3e-074c-47dd-8e7c-262bb2d584b1) - TDT4180

  |                              |                             |
  |------------------------------|-----------------------------|
  | Personas                     | Scenarios                   |
  | Human-centred requirements   | Usability measures          |
  | UX professional roles        | Design responsibilities     |
  | Usability test planning      | Test objectives             |
  | Context of use               | User requirements           |
  | Usability evaluation methods | Inspections & surveys       |
  | Human-centred design process | Activity order              |
  | Usability vs. User Experience| Satisfaction & principles   |
  | Storyboards                  | Master-apprentice principle |
  | Error tolerance              | Dialogue principles         |


---

# * Software Testing and Quality Series - TDT4242

A series focused on core software testing concepts, methodologies, and best practices.
 
**Advanced Software Engineering** focuses on methods for developing reliable and complex software systems, including safety-critical and AI-assisted applications.  
**Requirements specification** – turning stakeholder needs into precise technical requirements.  
**Testing management** – planning and automating modern test processes.  
**Code quality** – using static analysis, peer review, and refactoring.  
**Verification & validation** – evaluating large-scale and AI-driven systems.  

- [Software Testing and Quality Quiz – Part 1](https://www.flexiquiz.com/SC/N/SoftwareTesting1) - TDT4242
  Covers basic testing terminology, unit testing, and manual testing fundamentals.

- [Software Testing and Quality Quiz – Part 2](https://www.flexiquiz.com/SC/N/SoftwareTesting2) - TDT4242
  Explores automated testing, integration testing, and test strategies.

- [Software Testing and Quality Quiz – Part 3](https://www.flexiquiz.com/SC/N/SoftwareTesting3) - TDT4242
  Delves into testing methodologies.

- [Software Testing and Quality Quiz – Part 4](https://www.flexiquiz.com/SC/N/SoftwareTesting4) - TDT4242
  Examines advanced topics like performance testing and test coverage metrics.

- [Software Testing and Quality Quiz – Part 5](https://www.flexiquiz.com/SC/N/SoftwareTesting5) - TDT4242
  Explores requirements engineering and test setup.

- [Software Testing and Quality Quiz – Part 6](https://www.flexiquiz.com/SC/N/SoftwareTesting6) - TDT4242
  Explores code smells, DU-coverage and Devops.

- [Software Testing and Quality Quiz – Part 7](https://www.flexiquiz.com/SC/N/SoftwareTesting7) - TDT4242
  Explores domain testing, code smells, sustainability, all-pair combinatorial tests, and Devops terms
  |                          |                                     |
  |--------------------------|-------------------------------------|
  | DevOps Metrics           | Lead Time, Cycle Time, PCA          |
  | Combinatorial Testing    | All-pairs test design               |
  | Code Quality             | Code smells & refactoring           |
  | Sustainable Applications | Efficiency, scalability, accessibility |
  | Domain Testing           | Valid vs. invalid domains           |
  | Equivalence Partitioning | Input classes for test coverage     |
  | Boundary Value Analysis  | Edge cases of input ranges          |
  | Interior vs Exterior     | Just inside/outside domain values   |
  | Numeric Boundaries       | Age, salary, numeric ranges         |
  | Non-numeric Boundaries   | Password length, registration dates |


- [Software Testing and Quality Quiz - Part 8](https://www.flexiquiz.com/SC/N/SoftwareTesting8) - TDT4242
  Explores code refactoring, testing concepts, requirements quality, requirements classification, sustainable software requirements, branch and statement coverage.

  |                       |                      |
  |-----------------------|----------------------|
  | Refactoring           | Testing techniques   |
  | Test levels           | Quality attributes   |
  | Non-functional reqs   | Sustainability       |
  | Safety                | Test cases           |
  | Requirements quality  | Traceability         |
  | Coverage              | Random testing       |
  | Statement vs branch   | Adaptive testing     |


---

# * Java Programming - TDT4100

A foundational Java quiz for programmers looking to evaluate their language knowledge.

- [Java Programming Exam](https://www.flexiquiz.com/SC/N/JavaExam1)  

  |                        |                       |
  |------------------------|-----------------------|
  | Lambda expressions     | Collections           |
  | Primitive types        | Default values        |
  | Delegation             | Observer pattern      |
  | Inheritance            | Polymorphism          |
  | Design patterns        | Strategy & Factory    |
  | Streams & Matching     | Functional interfaces |
  | Encapsulation          | Object structure      |
  | Interfaces             | Abstract classes      |
  | Access modifiers       | Visibility            |
  | Method overloading     | Method overriding     |


---

# * Cryptography Fundamentals - TDT4237

A concise introduction to the world of secure communications and encryption techniques.

- [Cryptography Basics Quiz](https://www.flexiquiz.com/SC/N/Cryptography1)  
  
  |                            |                           |
  |----------------------------|---------------------------|
  | Block ciphers              | Rounds in ciphers         |
  | HMAC                       | Message authentication    |
  | Elliptic Curve Cryptography| Public-key efficiency     |
  | Certification Authorities  | Trust models              |
  | Public keys                | Private keys              |
  | Authentication             | Encryption                |
  | Security models            | Cryptographic evaluation  |
  | Cryptographic techniques   | Data protection           |


---

# * Software Security Series - TDT4237

A comprehensive series covering secure development practices and application-level security.

- [Software Security – Part 1](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart1) - TDT4237
  
  |                                                |                                                          |
  |------------------------------------------------|----------------------------------------------------------|
  | Recommended secure coding practices            | Symmetric encryption use in secure transmission          |
  | Asymmetric encryption (public/private keys)    | CVE vs CVSS purposes                                     |
  | Good security requirements                     | CIA Triad (Confidentiality, Integrity, Availability)     |
  | ROI of countermeasures after a data breach     | Defenses against session hijacking                       |
  | Buffer overflow defenses                       | Symmetric vs asymmetric encryption disadvantages         |
  | Django password validator implementation       | Weaknesses of password authentication & improvements     |
  | Psychological factors in social engineering    | Malicious AI attacks on recognition systems              |
  | Salt & pepper in cryptography (hashing)        | Conditions when salt fails                               |

- [Software Security – Part 2](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart2) - TDT4237

  |                                                  |                                                        |
  |--------------------------------------------------|--------------------------------------------------------|
  | Buffer overflow in C code                        | Secure coding practices (captchas, defenses)           |
  | Command injection attack                         | False cryptography statements                          |
  | Key generation best practices                    | Threat agent characteristics                           |
  | String concatenation vulnerability               | XML external entity (XXE) risk                         |
  | Storing passwords securely (hashing, salting)    | Other sensitive data exposure vulnerabilities          |
  | CVSS scoring metrics (Heartbleed case)           | Token exploitation and protection                      |
  | Insecure logging configuration                   | Secure logging and monitoring                          |
  | One-Time Pad encryption & properties             | OTP key reuse vulnerabilities                          |
  | Biba vs Bell-LaPadula models                     | Penetration testing and applications                   |
  | PoisingGPT attack steps                          | DevOps software deployment attack steps                |
  | Risk analysis threat dimensions                  | Zero-day exploit description                           |


- [Software Security – Part 3](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart3) - TDT4237

  |                                                 |                                                    |
  |-------------------------------------------------|----------------------------------------------------|
  | SQL injection vulnerability in Django code      | Secure coding fix for raw SQL                      |
  | Recommended secure practices                    | CIA triad violation                                |
  | Password policy exceptions                      | Sensitive information exposure vulnerabilities     |
  | Vulnerability prioritization (CVSS scoring)     | Common Vulnerability Scoring System (CVSS)         |
  | Common Vulnerabilities and Exposures (CVE)      | Importance of updating NuGet packages              |
  | Insecure web parameters (URL issues)            | CVE vs CVSS purposes                               |
  | Asymmetric key usage                            | Backdoors in software                              |
  | Countermeasure cost vs asset value              | Phishing/email scam defense                        |
  | Taboo traps in machine learning                 | Lawful consent under GDPR                          |
  | Logic bomb attack                               | Unicode sabotage in translation systems            |
  | Password policy enforcement in Django           | Secure logging and monitoring configuration        |


- [Software Security – Part 4](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart4) - TDT4237
  
  |                                                  |                                                       |
  |--------------------------------------------------|-------------------------------------------------------|
  | GDPR L-F-D-A-S-I-A fields                        | Business goals and business assets                    |
  | Business risks and risk dimensions               | Misuse case diagram and threat agent ranking          |
  | Attack tree for QR code misuse                   | Technical risks linked to business risks              |
  | Security requirements for technical risks        | GDPR violation discussion in crisis contexts          |
  | Machine learning use and misuse in identity      | GDPR principles (Art. 5)                              |
  | GDPR key points and legal bases                  | GDPR breach notification requirements                 |


- [Software Security - Part 5](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart5) - TDT4237

  |                                       |                                                     |
  |---------------------------------------|-----------------------------------------------------|
  | STRIDE threat categories              | Rule-Set-Based Access Control (RSBAC)               |
  | Organization-Based Access Control     | Lattice-Based Access Control (LBAC)                 |
  | Graph-Based Access Control (GBAC)     | Context-Based Access Control (CBAC)                 |
  | Bell-LaPadula model                   | Biba model                                          |
  | Clark-Wilson model                    | Brewer-Nash (Cinderella) model                      |
  | Password salting defenses             | Security by Design principles                       |
  | Bell-LaPadula vs Biba differences     | Bell-LaPadula vs Biba similarities                  |
  | Secure coding practices               | Security testing and code review                    |
  | Principle of least privilege          | Patch management strategy                           |
  | Access control mechanisms             | Common access control models                        |


---

# * Web Application Security Series - TDT4237

A deep dive into common web vulnerabilities and how to prevent them.

### > Web Security – Part 1
---  
- Quiz: [Web Security – Part 1](https://www.flexiquiz.com/SC/N/WebSecPart1) - TDT4237

  |                                              |                                                     |
  |----------------------------------------------|-----------------------------------------------------|
  | Session hijacking techniques                 | Man-in-the-Middle (MITM) attack                     |
  | Cross-Site Request Forgery (CSRF)            | Cross-Site Scripting (XSS)                          |
  | XSS protection for session hijacking         | CSRF protection for session hijacking               |
  | CORS overview                                | CORS misconfiguration vulnerabilities               |
  | Server injection attack types                | SQL injection defense via parameterization          |


### > Web Security – Part 2
---  
- Quiz: [Web Security – Part 2](https://www.flexiquiz.com/SC/N/WebSecPart2) - TDT4237

  |                                      |                                                     |
  |--------------------------------------|-----------------------------------------------------|
  | File upload attacks                  | XSS mitigation techniques                           |
  | Real-world CSRF example (Twitter)    | CSRF mitigation strategies                          |
  | Session cookie protection methods    | Web server information leakage prevention           |
  | Risks of not using HTTPS             | Clickjacking prevention                             |
  | Email fraud prevention               | Cookie protection rationale                         |


### > Web Security – Part 3
---  
- Quiz: [Web Security – Part 3](https://www.flexiquiz.com/SC/N/WebSecPart3) - TDT4237

  |                                                  |                                                      |
  |--------------------------------------------------|------------------------------------------------------|
  | HTTP vs cookie-based authentication              | XSS, CSRF, and XSSI differences                      |
  | Stored XSS vs Reflected XSS                      | CSRF and Referer header limitations                  |
  | Action tokens in CSRF protection                 | Token and cookie combination defense                 |
  | XSS prevention methods                           | HTTP header vulnerability rationale                  |
  | HTTP header injection examples                   | Content-Type sniffing and XSS risks                  |
  | Reducing XSS impact                              | Recommended XSS mitigation practices                 |


### > Web Security – Part 4
---  
- Quiz: [Web Security – Part 4](https://www.flexiquiz.com/SC/N/WebSecPart4) - TDT4237
 
  |                                   |                                     |
  |-----------------------------------|-------------------------------------|
  | Web security best practices       | STRIDE threat model                 |
  | Environmental creep               | Access control models               |
  | Bell-LaPadula principles          | Bell-LaPadula rules                 |
  | SAML SSO components               | SAML use cases                      |
  | Stack overflow causes             | Call stack behavior                 |
  | Memory overflow types             | Memory safety across languages      |
  | Unsafe defaults in C/C++          | Safe defaults in C#                 |
  | Website copier tools              | HTTrack and VisualWget usage        |
  | Web debugging proxies             | Firefox Dev Tools and Fiddler       |
  | Security toolkits                 | Burp Suite, OWASP ZAP, Kali Linux   |
  | Google Dorking operators          | SSRF attack scenarios               |
  | Rainbow table protection          | Security by Design – goal           |
  | Least privilege principle         | Threat modeling importance          |


---

# * Algorithms and Data Structures - TDT4120

**Content:**  
- Efficiency analysis, recursion, divide-and-conquer  
- Ordering, searching, sorting, hashing  
- Dynamic programming & greedy methods  
- Graph algorithms: shortest path, matching, spanning tree, max flow  
- Basics of complexity theory  

**Learning outcome:**  
- Recognise and apply a wide range of algorithms  
- Analyse time/space costs  
- Design new solutions when needed  
- Foundation for later AI, cyber-security, and systems courses


### > Algorithms and Data Structures – Part 1 - TDT4120
---  
*Covers topics from [Lecture 1 – Problems and Algorithms](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of1), [Lecture 2 – Data Structures](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of2), [Lecture 3 – Divide and Conquer](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of3), [Lecture 10 – Single-Source Shortest Path](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of10), and [Lecture 13 – NP-Completeness](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of13).*

Quiz: [Algorithms and Data Structures – Part 1](https://www.flexiquiz.com/SC/N/Algdat1)  

  |                                        |                                        |
  |----------------------------------------|----------------------------------------|
  | NP-completeness and implications       | Traveling Salesperson problem          |
  | Shortest-path challenges               | Exact vs near-optimal solutions        |
  | Offline vs online algorithms           | Loop invariants in SUM-ARRAY           |
  | Selection sort invariant and bounds    | Linear search cases                    |
  | Best-case sort thought experiment      | Master Theorem fill-in-the-blank       |
  | Θ(n log n) two-sum algorithm           | Ranking growth rates                   |
  | Simplifying asymptotic expressions     | Converting to tight Θ-notation         |
  | First-semester algorithm checklist     | Essential analysis skills              |

---

### > Algorithms and Data Structures – Part 2 - TDT4120
---  
*Links concepts from [Lecture 1](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of1), [Lecture 3](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of3), [Lecture 4](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of4), [Lecture 7](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of7), [Lecture 9](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of9), [Lecture 10](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of10), [Lecture 12](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of12), and [Lecture 13](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of13).*

Quiz: [Algorithms and Data Structures – Part 2](https://www.flexiquiz.com/SC/N/Algdat2)  

  |                                       |                                        |
  |---------------------------------------|----------------------------------------|
  | Growth rate expressions               | Big-O, Θ, Ω, o, ω symbols              |
  | Classifying formulas                  | Combining asymptotic bounds            |
  | Insertion vs Merge vs Quicksort       | Best/avg/worst-case analysis           |
  | Relax(u, v, w) in Dijkstra            | Bellman-Ford differences               |
  | Kruskal and MST construction          | New-SSSP proposal                      |
  | Greedy-choice property limits         | Pseudopolynomial vs NP-hard            |
  | Ford-Fulkerson and hyperflows         | Pivot choice impact in Quicksort       |
  | Algorithm theory and implementation   | Full algorithm toolbox review          |

---

### > Algorithms and Data Structures – Part 3 - TDT4120
---  
*Connects to [Lecture 2](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of2), [Lecture 3](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of3), [Lecture 6](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of6), [Lecture 7](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of7), [Lecture 9](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of9), [Lecture 10](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of10), [Lecture 12](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of12), and [Lecture 13](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of13).*

Quiz: [Algorithms and Data Structures – Part 3](https://www.flexiquiz.com/SC/N/Algdat3)  

  |                                        |                                        |
  |----------------------------------------|----------------------------------------|
  | Greedy-choice property                 | When greedy algorithms work            |
  | Data structure trade-offs              | Selection sort with BST                |
  | Heaps vs binary vs splay trees         | Naïve recursion vs memoization         |
  | Dynamic programming speed-up           | Structural properties for DP           |
  | Classic vs randomized algorithms       | Quicksort vs Randomized Quicksort      |
  | Select vs Randomized Select            | Select in Quicksort                    |
  | Insertion/merge/quick/heap sort        | Sort behavior comparisons              |
  | NP and NP-complete classes             | Verification vs solution difficulty    |
  | Prim vs Kruskal                        | Ford-Fulkerson max-flow                |
  | Max-flow and capacity size             | Master Theorem revisited               |
  | Heap sort best/avg/worst cases         | Algorithm paradigms and asymptotics    |

---

### > Algorithms and Data Structures – Part 4 - TDT4120
---  
*Draws from [Lecture 1](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of1) and [Lecture 3](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of3).*

Quiz: [Algorithms and Data Structures – Part 4](https://www.flexiquiz.com/SC/N/Algdat4)  

  |                                       |                                         |
  |---------------------------------------|-----------------------------------------|
  | Ω(n²) bound for insertion sort        | Optimal α for maximum crossings         |
  | Refined α constraints                 | Debunking Big-O claims                  |
  | max{f,g} = Θ(f+g)                     | "At least O(n²)" critique               |
  | o(g) and ω(g) contradiction           | α-weighted sum manipulation             |
  | Factorial vs polynomial growth        | Solving k log k = Θ(n)                  |
  | Master Theorem cases                  | Merge Sort recurrence matching          |

---

### > Algorithms and Data Structures – Part 5 - TDT4120
---  
*Focuses on [Lecture 3](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of3) and [Lecture 4](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of4).*

Quiz: [Algorithms and Data Structures – Part 5](https://www.flexiquiz.com/SC/N/Algdat5)  

  |                                  |                                    |
  |----------------------------------|------------------------------------|
  | Big-O, Θ, o comparison           | Complexity class ranking           |
  | Asymptotic relationships         | Tight bound combinations           |
  | Divide-and-conquer algorithms    | Binary search                      |
  | Merge sort                       | Quick sort                         |
  | Counting sort                    | Radix sort                         |
  | Bucket sort                      | Bubble sort                        |
  | Sort case analysis               | Worst-case pivot choices           |
  | Randomized vs median-of-medians  | Pivot strategy and stability       |
  | Partition strategies             | Left-child/right-sibling trees     |

---

### > Algorithms and Data Structures – Part 6 - TDT4120
---  
*Reflects [Lecture 2](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of2), [Lecture 4](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of4), [Lecture 5](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of5), and [Lecture 9](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of9).*

Quiz: [Algorithms and Data Structures – Part 6](https://www.flexiquiz.com/SC/N/Algdat6)  

  |                                          |                                          |
  |------------------------------------------|------------------------------------------|
  | Free tree to rooted tree                 | Height of complete binary tree           |
  | Binary heap child indexing               | Max-heap invariant                       |
  | BUILD-MAX-HEAP running time              | MAX-HEAPIFY running time                 |
  | Heap vs BST property                     | Expected height of random BST            |
  | Logarithmic height data structures       | Maximum removal cost in heap             |
  | Top-k retrieval from heap                | Left-child/right-sibling representation  |
  | Pointer overhead                         | Amortized O(1) in bucket arrays          |
  | BST sorted order printing                | Θ(n) unbalanced BST operations           |
  | Θ(log n) heap operations                 | Heap property vs heap invariant          |
  | Heapsort iteration effect                | BUILD-HEAP vs repeated inserts           |
  | BST ordering vs heap ordering            | Spanning tree definitions                |
  | Tree-sort vs Heapsort                    | Repeated steps and decomposition         |
  | Design paradigms and induction proofs    | Hardness reductions                      |
  | HEAP-EXTRACT-MAX mechanics               |                                          |

---

### > Algorithms and Data Structures – Part 7 - TDT4120
---  
*Dedicated to [Lecture 6 – Dynamic Programming](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of6).*
*Reflects [Lecture 1](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of1), [Lecture 11](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of11), [Lecture 13](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of13).*

Quiz: [Algorithms and Data Structures – Part 7](https://www.flexiquiz.com/SC/N/Algdat7)  

  |                                                  |                                                         |
  |--------------------------------------------------|---------------------------------------------------------|
  | Divide-and-conquer                               | Dynamic Programming Basics            |
  | Optimal substructure                             | Overlapping subproblems                                 |
  | Design steps of a dynamic programming algorithm  | Subproblem graph: nodes and edges                       |
  | Time complexity of dynamic programming           | Rod-cutting problem: number of ways to cut              |
  | Running time of naive recursive Cut-Rod          | Time complexity of memoized Cut-Rod                     |
  | Array r[j] in Bottom-Up-Cut-Rod                  | Reconstruction array in Extended Bottom-Up-Cut-Rod      |
  | DP Design Process          | Subproblem graphs & recurrence relations |
  | Cut-Rod Problem            | Naive recursion, memoization, bottom-up DP |
  | LCS (Longest Common Subseq.) | Stable Matching Variants |
  | 0/1 Knapsack               | Θ(nW) complexity & polynomial-time discussion |
  | Playlist Problem           | Complexity Considerations |
  | Graph Algorithms           | Odd cycles, shortest paths, transitive closure |
  | Floyd–Warshall Variants    | Time analysis of DP algorithms |
  
---

### > Algorithms and Data Structures – Part 8 - TDT4120
---
*Asymptotics, comparisons, recurrences, sorting, reductions, and a small LP modeling case.*  
*Reflects [Lecture 1](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of1), [Lecture 3](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of3), [Lecture 13](https://github.com/henrhoi/Algdat-TDT4120?tab=readme-ov-file#of13).*

Quiz: [Algorithms and Data Structures – Part 8](https://www.flexiquiz.com/SC/N/Algdat8)

| Topic                                   | Key results & reminders                                                                                                                                                                                                                   |
|-----------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Order-of-growth ranking                 | Fast → slow: 1) Θ(1), 2) Θ(log log n), 3) Θ(log n), 4) Θ(√n), 5) Θ(n), 6) Θ(n log n), 7) Θ(n²), 8) Θ(n³), 9) Θ(nᵏ) (fixed k>1), 10) Θ(cⁿ), 11) Θ(n!), 12) Θ(nⁿ).                                                                          |
| Asymptotic comparison (O/Ω/Θ/o/ω)       | Use limits/ratios. Example: f(n)=n²lg n + n + nlg n vs g(n)=n² ⇒ f/g = lg n + o(1) → ∞ ⇒ f ∈ Ω(g) and ω(g); not O/Θ. 2ⁿ vs 2^{n/2}: ratio 2^{n/2} → ∞ ⇒ 2ⁿ ∈ ω(2^{n/2}).                                                                |
| Combining bounds                        | Ω(n)+Θ(n²lg n)+O(n³) ⇒ typical tight term Θ(n²lg n); best case within Ω(n)∩O(n²lg n); worst case within Ω(n²lg n)∩O(n³).                                                                                                                 |
| Algebra with Θ/O/Ω                      | Θ(n²)+O(lg n) ⇒ Θ(n²). Θ(n)+O(n²)+Ω(n²) ⇒ Θ(n²). If f ∈ o(g) ⇒ f ∈ O(g). If f ∈ Θ(g) ⇒ f ∈ O(g) ∩ Ω(g). For any ε>0: n lg n ∈ o(n^{1+ε}); and n^a ∈ o(n^b) for a<b.                                                                    |
| Sorting properties (CLRS variants)      | Merge-sort: stable, Θ(n log n) time, Θ(n) extra space. Quicksort: in-place, not stable; expected Θ(n log n), worst Θ(n²). PARTITION runs Θ(n), places pivot q with A[p..q−1] ≤ A[q] ≤ A[q+1..r].                                           |
| K-LARGEST (size-k buffer)               | Init O(k); scan n items with ≤k bubble-steps ⇒ **O(nk)** time, **O(k)** space. (Min-heap variant: **O(n log k)**, **O(k)** space.)                                                                                                       |
| Reductions (X ≤ₚ Y)                     | If Y ∈ P and X ≤ₚ Y ⇒ X ∈ P. If X is NP-hard and X ≤ₚ Y ⇒ Y is NP-hard. (X ≤ₚ Y alone doesn’t imply Y ≤ₚ X.)                                                                                                                             |
| Linear program (hammers & nails)        | Maximize **3000x + 1000y** subject to **2x + y ≤ 100**, **x + 2y ≤ 80**, **x ≤ 40**, **x,y ≥ 0**; optimum **(x,y)=(40,20)** gives **140 000 NOK**.                                                                                       |
| Master Theorem example                  | T(n)=32T(n/4)+3n³+7n ⇒ a=32, b=4, n^{log_b a}=n^{2.5}, f(n)=Θ(n³)=n^{2.5+0.5} ⇒ Case 3 (regularity) ⇒ **Θ(n³)**.                                                                                                                         |
| Substitution (Ω-proofs)                 | T₁ ≥ c n³ − 5n² ✔; T₂ ≥ c n⁴ + 5n² ✔ (stronger); T₃ ≥ c n³ + n ✔; T₄ ≥ c n³ − 1 ✔ ⇒ all four satisfy Ω(n³) (assuming bases hold).                                                                                                        |
| Recursion heights                       | T(n)=T(n/10)+T(n/5)+T(n/π)+n³: height by slowest shrink (/π) ⇒ **Θ(log_π n)**.   T(n)=4T(⌊√n⌋)+n³: n→√n each level ⇒ **Θ(log log n)**.                                                                                                   |
| Mutual recursion cost                   | With C(n)=Θ(√n): A(n)=2A(n/3)+Θ(√n) ⇒ **Θ(n^{log_3 2})**; 36 calls on n/6 with Θ(n²) work ⇒ **Θ(n² log n)**.                                                                                                                             


---


**TDT4120 - Resources:**

- [VisuAlgo: Sorting](https://visualgo.net/en/sorting)
- [henrhoi/Algdat-TDT4120 (GitHub)](https://github.com/henrhoi/Algdat-TDT4120)
- [Xtrah/TDT4120 (GitHub)](https://github.com/Xtrah/TDT4120)

- [NTNU TDT4120 — Algorithms and Data Structures (official course page)](https://www.ntnu.edu/studies/courses/TDT4120). 
- [CP-Algorithms — Algorithms for Competitive Programming](https://cp-algorithms.com/).


---

# * Model-Driven Software Engineering - TDT4250

**Content:**  
- Introduction to meta-programming and meta-modeling  
- Domain-Specific Languages (DSLs), syntax and semantics  
- Model-driven development of software: transformations, code generation  
- Constraints and queries in models (e.g., OCL)  
- Component-based development and architectures  
- Software Product Lines: variability at design-time and run-time  
- Deployment, frameworks, and continuous integration of modular systems  

**Learning outcome:**  
- **Knowledge:** Understand general methods for modeling, designing, and implementing modular software; principles of model-driven development  
- **Skills:** Gain practical ability to model, design, and implement modular software using modern frameworks and model-based techniques  
- **General competence:** Be able to select appropriate methods and techniques for developing modular and model-driven software systems


### > Model-Driven Development – Part 1 - TDT4250
---
*Dedicated to [Lecture 1 – Introduction to MDE](https://www.flexiquiz.com/SC/N/ModelDrivenDev1).*  
*Reflects [Schmidt 2006](https://ieeexplore.ieee.org/document/1610613) and [Whittle et al. 2014](https://ieeexplore.ieee.org/document/6824042).*  

Quiz: [Model-Driven Development – Part 1](https://www.flexiquiz.com/SC/N/ModelDrivenDev1)  

  |                                                  |                                                         |
  |--------------------------------------------------|---------------------------------------------------------|
  | Models + Transformations = Artifacts             | DSLs (SQL, HTML, Kubernetes YAML, Regex)                |
  | CASE tools vs. MDE                               | Why CASE failed in the 80s                              |
  | Metamodels: "model of models"                    | Legend/map analogy                                      |
  | DSL vs GPL                                       | Examples and differences                                |
  | Industrial use of MDE (Whittle 2014)             | Partial system generation, architecture documentation   |
  | Benefits beyond code generation                  | Explicit architectures, separation of concerns           |
  | Adoption strategies                              | Bottom-up (developer-led) vs. top-down mandates         |
  | Models ≠ Reality                                 | Abstraction, assumptions, purpose                       |
  | Correct-by-construction                          | Contrast with construct-by-correction                   |
  | MDE in domain-focused companies                  | Automotive, printers, finance vs. consultancies         |


### > Software Product Lines – Part 2 - TDT4250
---
*Dedicated to [Lecture 2 – Software Product Lines](https://www.flexiquiz.com/SC/N/ModelDrivenDev2).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Software Product Lines – Part 2](https://www.flexiquiz.com/SC/N/ModelDrivenDev2)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Definition of SPL                                | Family of products sharing core assets + controlled variability |
  | Features                                         | User-visible functionality, building blocks for variability      |
  | Domain vs Application Engineering                | For reuse (platform) vs with reuse (products)                   |
  | Adoption strategies                              | Proactive, Extractive, Reactive – pros/cons                     |
  | Feature modeling basics                          | Mandatory, optional, OR, XOR groups                             |
  | Constraints in feature models                    | Example: MST ⇒ Undirected ∧ Weighted                            |
  | Benefits of SPL                                  | Reduced cost, faster time-to-market, improved quality            |


### > Variability Implementation – Part 3 - TDT4250
---
*Dedicated to [Lecture 3 – Variability Implementation](https://www.flexiquiz.com/SC/N/ModelDrivenDev3).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Variability Implementation – Part 3](https://www.flexiquiz.com/SC/N/ModelDrivenDev3)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Binding times                                    | Compile-time, load-time, run-time                               |
  | Language-based mechanisms                        | Parameters, design patterns, frameworks, components             |
  | Tool-driven mechanisms                           | Version-control, build systems, preprocessors                   |
  | Preprocessors                                    | Conditional compilation, disciplined vs undisciplined use        |
  | Frameworks                                       | White-box (inheritance) vs black-box (plug-ins, hot spots)       |
  | Components vs Plug-ins                           | Reuse beyond SPL vs tailored to framework                       |
  | Aspect-Oriented Programming (AOP)                | Aspects, join points, pointcuts, advice, weaving                 |
  | Virtual Separation of Concerns (VSOC)            | Views, tracing, visualization for feature separation             |
  | Granularity                                      | Fine-grained (annotations) vs coarse-grained (composition)       |
  | Evaluation criteria                              | Preplanning, traceability, separation, info hiding, uniformity   |


### > Variability with Parameters – Classic Language-Based Mechanism - Part 4 - TDT4250
---
*Dedicated to [Lecture 4 – Parameters](https://www.flexiquiz.com/SC/N/ModelDrivenDev4).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Variability Implementation – Part 4](https://www.flexiquiz.com/SC/N/ModelDrivenDev4)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Core idea                                        | Variability via `if` / `switch` guarded by configuration params |
  | Sources of parameters                            | Command-line, config files, user prefs, hard-coded values, args |
  | Mapping to features                              | Typically one Boolean parameter per feature                     |
  | Pros                                             | Simple, widespread, flexible (can switch at runtime)            |
  | Cons                                             | All code shipped, runtime overhead, weak compile-time guarantees|
  | Security risk                                    | Disabled code still deployed, larger attack surface             |
  | Code quality issues                              | Globals break modularity, long arg lists = code smell           |
  | Best practice                                    | Use a **Parameter Object** to group options                     |
  | Traceability                                     | Poor; feature code scattered and tangled                        |
  | Relation to MDE                                  | Easy to adopt, but less disciplined than DSLs or composition    |


### > Domain-Specific Languages – Modeling and Metamodeling - Part 5 - TDT4250
---
*Dedicated to [Lecture 5 – Domain-Specific Languages](https://www.flexiquiz.com/SC/N/ModelDrivenDev5).*  
*Reflects [Apel et al. 2013, *Feature-Oriented Software Product Lines*](https://link.springer.com/book/10.1007/978-3-642-37521-7).*  

Quiz: [Variability Implementation – Part 5](https://www.flexiquiz.com/SC/N/ModelDrivenDev5)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | Core idea                                        | DSLs provide domain-optimized abstractions, reducing the problem–solution gap |
  | GPL vs DSL                                       | GPLs are Turing complete and general; DSLs are limited but simpler and domain-focused |
  | Examples                                         | SQL, HTML, BPMN, VHDL, Simulink, Spreadsheets, Scratch          |
  | Structure of a modeling language                 | Abstract syntax (concepts), Concrete syntax (notation), Semantics (meaning) |
  | Domain analysis                                  | Identify key concepts, relations, and rules; foundation for metamodel |
  | Language design & validation                     | Formalize concepts in a metamodel; check rules with stakeholders |
  | Implementation                                   | Use frameworks like EMF/Ecore, Xtext, GMF, Sirius, Acceleo, QVT |
  | Low-code vs MDD                                  | Low-code repackages MDD ideas, marketed for rapid business apps; clearer message but less | open, more vendor lock-in |
  | Strengths                                        | Familiar notation for domain experts, concise and correct-by-construction models |
  | Weaknesses                                       | Narrow scope, may require custom tooling, risk of lock-in with closed platforms |


### > MOF & Model-Driven Architecture (MDA) - Part 6 - TDT4250  
---  
*Dedicated to [Lecture 6 – MOF and the Model-Driven Architecture (MDA)](https://www.flexiquiz.com/SC/N/ModelDrivenDev6).*  
*Reflects OMG MDA principles and the MOF/eMOF foundations.*  

Quiz: [MOF & MDA – Part 6](https://www.flexiquiz.com/SC/N/ModelDrivenDev6)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | **Core idea**                                    | Use models as first-class artefacts to increase portability, interoperability and automation. MDA organises specifications as models + transformations.  |
  | **Primary motivations**                          | Interoperability (vendor/tool independence) and portability (platform independence). MDA is a guideline for applying MDE practices in the SDLC.   |
  | **Key standards**                                | MOF (metamodeling / M3), UML (notation), XMI (XML interchange), QVT (model→model transformations).  |
  | **MOF basics**                                   | MOF is an object-oriented metamodeling language (NamedElement, TypedElement, MultiplicityElement). eMOF vs cMOF; MOF is reflexive (MOF defined with MOF).  |
  | **Layering (M3→M0)**                             | M3 = meta-metamodel (MOF), M2 = metamodel (e.g. UML/Ecore), M1 = model (domain model), M0 = runtime instances/data — models *conformTo* their metamodel.  |
  | **PIM / PSM / CIM**                              | PIM = platform-independent model, PSM = platform-specific model, (CIM = computation-independent/business model). Transformations map PIM → PSM (parameterisable).  |
  | **Model transformations**                        | Model→Model (QVT) and Model→Text (code generators). Transformations can be reused, tuned and audited (security, optimisation).   |


### > Eclipse Modeling Framework (EMF) & Ecore - Part 7 - TDT4250  
---  
*Dedicated to [Lecture 7 – Eclipse Modeling Framework (EMF)](https://www.flexiquiz.com/SC/N/ModelDrivenDev7).*  
*Based on the EMF/Ecore lecture material and examples.*  

Quiz: [EMF & Ecore – Part 7](https://www.flexiquiz.com/SC/N/ModelDrivenDev7)  

  |                                                  |                                                                 |
  |--------------------------------------------------|-----------------------------------------------------------------|
  | **Core idea**                                    | EMF provides a pragmatic bridge between modelling and Java: define an Ecore metamodel, then generate Java APIs, editors and XMI persistence. :contentReference[oaicite:0]{index=0} |
  | **Ecore (role)**                                 | Ecore is Eclipse’s MOF-like metamodeling language (an EMF core metamodel). It implements MOF concepts (EClass, EAttribute, EReference, EPackage, EObject) for the Eclipse ecosystem. :contentReference[oaicite:1]{index=1} |
  | **Key metamodel elements**                       | `EPackage`, `EClass`, `EAttribute` (EDataType), `EReference` (link to EClass), `EEnum`, `EDataType`, `EOperation`, `EFactory`, `EObject`. :contentReference[oaicite:2]{index=2} |
  | **EAttribute vs EReference**                     | `EAttribute` = value-typed property (String, int, enum); `EReference` = reference to other `EObject` instances (links/associations). Multiplicity and containment are configurable. :contentReference[oaicite:3]{index=3} |
  | **Containment / composition**                    | Containment is modelled with `EReference` where `containment=true`. Containment defines the model tree (persistence/ownership) and lifecycle (contained objects saved/deleted with container). :contentReference[oaicite:4]{index=4} |
  | **Resources & ResourceSet**                      | `Resource` = unit of persistence (commonly an XMI file/URI). `ResourceSet` groups resources and resolves cross-resource references. Use `ResourceFactory` (e.g., `XMIResourceFactoryImpl`) to register serializers. :contentReference[oaicite:5]{index=5} |
  | **Code generation & runtime**                    | EMF generates a Java `interface` + `*Impl` class per `EClass`, a `Package` with metadata constants, and a `Factory` to instantiate objects; generated code is annotated with `@generated`. :contentReference[oaicite:6]{index=6} |


---

# * Information Systems – TDT4175

**Content:**  
- Taxonomies and types of information systems (e.g., TPS, MIS, DSS, ERP, CRM, SCM)  
- ERP systems: functionality, selection, and introduction in organizations  
- IS strategy, digitalization, and process improvement  
- IS development methods: needs analysis, business-process modeling (as-is/to-be, e.g., BPMN), and quality evaluation of models/systems  
- Requirements engineering: elicitation techniques, modeling, validation, and documentation  
- Ethics and responsible use of information systems (privacy, security, societal impact)

**Learning outcome:**  
- **Knowledge:** Understand how business/organizational strategies relate to IS strategy; know major IS categories; grasp methods for IS deployment and improvement; understand requirements engineering approaches; recognize ethical issues in IS.  
- **Skills:** Elicit and document requirements; model and analyze business processes with BPMN; assess and communicate improvements to IS and organizational processes.  
- **General competence:** Relate IS choices to organizational goals and ethical considerations; argue for and present IS proposals grounded in stakeholder needs and process models.

### > Information Systems – Part 1 - TDT4175
---
*Dedicated to [Lecture 1 – Introduction to Information Systems](https://www.flexiquiz.com/SC/N/infosystems1).*  
*Reflects core TDT4175 topics: IS types, ERP, strategy & process improvement, requirements & BPMN, ethics.*

Quiz: [Information Systems – Part 1](https://www.flexiquiz.com/SC/N/infosystems1)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **System model**                                  | Input → Processing → Output ↺ Feedback; **efficiency** vs **effectiveness**; feedback as control |
| **Data vs. information**                          | Quality traits: accurate, relevant, timely, complete, simple, secure, verifiable            |
| **CBIS components**                               | Hardware, software, data/databases, telecommunications, people, procedures                  |
| **IS taxonomy**                                   | TPS, MIS, DSS, ERP, CRM, SCM—when to use which                                              |
| **ERP essentials**                                | Integration across functions; selection/intro strategies; change management                 |
| **MIS vs. DSS**                                   | Routine reporting vs. model-driven what-if and ad-hoc analysis                              |
| **Intranet vs. extranet**                         | Internal portal vs. controlled access for partners/suppliers                                |
| **Process modeling (BPMN)**                       | As-is/to-be, bottlenecks, KPIs; grounding improvement proposals                             |
| **Development lifecycle**                         | Investigation → Analysis (**what**) → Design (**how**) → Implementation → Maintenance       |
| **Change approaches**                             | Continuous improvement (kaizen) vs. Business Process Reengineering (BPR)                    |
| **Requirements engineering**                      | Elicitation, modeling, validation, prioritization, documentation                            |
| **Ethics & security**                             | Privacy, access control, validation, governance, societal impact                            |


### > Information Systems – Part 2 - TDT4175
---
*Dedicated to [Lecture 2 – Information Systems in Organizations](https://www.flexiquiz.com/SC/N/infosystems2).*  
*Reflects core TDT4175 Lesson 2 topics: value chain, SCM/CRM, org structures, change & sourcing, BPR vs CI, diffusion/infusion, applications portfolio, alignment & strategy, evaluation & roles.*

Quiz: [Information Systems – Part 2](https://www.flexiquiz.com/SC/N/infosystems2)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Why IS in organizations**                       | IS transforms office/knowledge work; embedded in daily operations across all functions      |
| **IS role in processes**                          | Traditional: monitor/control; Contemporary: integral to input–transform–output             |
| **Value chain**                                   | Upstream (inbound/storage) vs downstream (outbound/marketing/service); value-add focus     |
| **SCM basics**                                    | Plan–source–make–deliver; e-marketplaces/B2B exchanges; scheduling, monitoring, control    |
| **CRM basics**                                    | Manage encounters; data from sales/surveys/web; loyalty/retention and targeted offers      |
| **Org structures**                                | Traditional→flat (empowerment); Project/Team; **Virtual** (geo/time distributed, ICT-driven)|
| **Change types**                                  | Sustaining vs **disruptive**; address resistance via involvement and change champions       |
| **Sourcing & capacity**                           | **Outsourcing** (focus core, contract risks); **On-demand**/utility computing; **Downsizing** |
| **Org learning & improvement**                    | Continuous improvement (incremental) vs **BPR** (radical, cross-functional redesign)       |
| **Diffusion vs infusion**                         | Diffusion = how wide across org; Infusion = how deep within a function; TAM: ease/usefulness |
| **Applications portfolio**                        | **Support**, **Key operational**, **Strategic**, **Future strategic**; lifecycle from idea→standard |
| **Alignment & success**                           | Tie IS to goals/processes; exec sponsorship; early user involvement; clear requirements; PM |
| **Competitive advantage**                         | Outperform industry via quality/service/cost; smart IS investment, not just higher spend   |
| **Porter’s five forces**                          | Rivalry, new entrants, substitutes, buyer power, supplier power                             |
| **Strategy levers**                               | Cost leadership, differentiation, niche focus, alter industry, new offerings, improve lines |
| **Evaluating IS**                                 | Productivity, ROI, earnings growth, market share, customer satisfaction, **TCO**            |
| **Risk awareness**                                | Large projects (e.g., ERP/e-commerce) can fail; cost > benefit if mismanaged               |
| **IS function & roles**                           | **CIO**; Operations (systems/LAN/web); Dev (analysts, programmers, agile); Support (DBA, training, helpdesk, web admin); Info service units |

### > Information Systems – Part 3 - TDT4175
---
*Dedicated to [Lecture 3 – Business Process Modeling & Value Framework](https://www.flexiquiz.com/SC/N/infosystems3).*  
*Reflects core TDT4175 Lesson 3 topics: process modeling goals, SEQUAL framework, quality dimensions, modeling languages/methods/tools, value framework, participatory techniques, BPMN evaluation, and big data perspectives.*

Quiz: [Information Systems – Part 3](https://www.flexiquiz.com/SC/N/infosystems3)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Why process modeling**                         | Sense-making, communication, documentation, training, compliance, automation, improvement   |
| **SEQUAL quality dimensions**                    | Physical, empirical, semantic, pragmatic, social, deontic; balance across stakeholders/goals|
| **Modeling goals**                               | As-is vs to-be vs ought-to-be; strategic, operational, learning, standardization            |
| **Modeling practices**                           | Choice of methods, languages, tools; formal vs informal; reuse & managing practices         |
| **Knowledge maturing model**                     | Exploration → individuation → community → transformation → training/piloting → institutionalization |
| **Managing modeling**                            | Separate roles: process owner, model manager, modeling facilitator                          |
| **Challenges & solutions**                       | Updating models, merging across org units, unintended use, sustaining ownership             |
| **Participatory techniques**                     | **STWT** (socio-technical walkthrough), **Modeling Conference** (search conference blend)   |
| **BPMN strengths**                               | Widely adopted, high representational capability, tool support, cross-org communication     |
| **BPMN weaknesses**                              | Weak resource modeling, gateway confusion, semantic perversity (e.g., data object symbol)   |
| **Notation quality principles**                  | Semiotic clarity, discriminability, semantic transparency, complexity mgmt, cognitive fit   |
| **Tool evaluation**                              | Signavio-Oryx (full palette), Bizagi, Camunda, ARIS, Visual Paradigm, Bonita – varied support |
| **Process improvement modes**                    | Instance reuse, type-level generalization, simulation, interactive activation               |
| **Reflection & learning**                        | Reflection in/on action; collaborative reflection; tools to capture/trigger reflections     |
| **Big Data V’s**                                 | Volume, velocity, variety, veracity, visualization, value                                   |
| **Big Data + SEQUAL**                            | Volume→physical, veracity→social/semantic, visualization→empirical, value→deontic           |
| **Process mining**                               | Event logs → discovery, monitoring, improvement; link BPM lifecycle to real execution       |
| **Future directions**                            | Multi-perspective modeling, top-down “Future Operating Model” vs bottom-up workflows, hybrid declarative/imperative |
| **Key concerns in BPM (van der Aalst)**          | Modeling languages, enactment infrastructure, model analysis, mining, flexibility, reuse    |
| **Enduring role of modeling**                    | Even with automation/mining, models remain vital for human communication & knowledge sharing|

---

### > Information Systems – Part 4 - TDT4175
---
*Dedicated to [Lecture 4 – Business Process Modeling: Method & Style](https://www.flexiquiz.com/SC/N/infosystems4).*  
*Reflects core TDT4175 Lesson 4 topics: Business Process Model and Notation (BPMN) Method and Style (Chapters 1–6 of Bruce Silver), Level-1 palette, top-down modeling method, style rules for clarity and traceability, message flows and pools, end states, and practical modelling exercises.*

Quiz: [Information Systems – Part 4](https://www.flexiquiz.com/SC/N/infosystems4)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Why BPMN Method & Style**                      | Make BPMN diagrams useful and unambiguous: combine the standard notation with a prescriptive method and concrete style rules so business and IT can share and act on models. |
| **Key standards & terms**                        | BPMN = Business Process Model and Notation; OMG = Object Management Group; XML = eXtensible Markup Language; BPMN-I = BPMN Interchange (constrained interchange rules). |
| **Core modelling goal**                          | Produce readable, correct, complete, and consistent end-to-end models that fit on one page at the top level and expand hierarchically. |
| **Level-1 palette (practical subset)**           | Start/End events, Activity / Task (VERB-NOUN labels), Subprocess / Call Activity, Sequence flow, Message flow, Pool / Lane, Gateways (Exclusive, Parallel), Data Object, Text annotation. |
| **Top-down Method (practical steps)**            | 1) Define scope (instance, start, end states). 2) Create a high-level map of major subprocesses. 3) Draw a one-page top (end-to-end) diagram. 4) Expand each collapsed subprocess on child pages. 5) Add and replicate message flows and labels for traceability. |
| **End states (practical concept)**               | Model distinct outcomes explicitly (for example “Order Complete”, “Order Rejected”) using separate labeled end events so downstream logic and gateways map cleanly across levels. |
| **Message flows & pools**                        | Use black-box pools for external participants; show message flows for external interactions and replicate message names/counts in child diagrams where relevant. Do not attach message flows to gateways. |
| **Naming & labeling (Style rules)**              | Activities use VERB-NOUN (for example “Approve Invoice”); gateways can be labelled as questions (for example “Approved?”) and gates should have labels or at most one unlabeled default to avoid ambiguity. |
| **Traceability rules (practical)**               | Child diagram titles must match collapsed subprocess names; message flow labels and counts must match between parent and child; subprocess child diagrams must expose labeled end events that correspond to parent-level gateways. |
| **Gateway best practice**                        | Use Exclusive (XOR) gateways for alternatives and label outgoing gates (or the gateway) to document decision conditions; use Parallel (AND) gateways for unconditional concurrency and ensure proper joins. |
| **Level-1 modelling boundaries**                 | Keep the top diagram compact (rough guideline: ~5–10 major steps). Put details in child diagrams; avoid executable-only artifacts (for example Script tasks) at Level-1. |
| **Tooling & validation**                         | Encode Style rules as tool validations where possible (flag unlabeled messages, unmatched message flows, gateways with all unlabeled gates, mismatched subprocess names) to improve consistency. |
| **Common modelling mistakes to avoid**           | Putting external partner internals in black-box pools, unlabeled gates, implicit end states, message flows attached to gateways, mixing executable task types (script/manual) in descriptive diagrams. |
| **Practical classroom exercises**                | • Workshop: convert sticky-note process to a one-page top diagram with 5–8 collapsed subprocesses; expand one subprocess and replicate message flows. • Demo: model a scheduled job with a Timer start event labeled “Mondays at 08:00” and a customer-driven process with a Message start event labelled “Receive Purchase Order”. |
| **Learning outcomes for students**               | Be able to design a top-level end-to-end process map, apply the Level-1 palette correctly, name activities VERB-NOUN, create child expansions that preserve message and end-state traceability, and run basic style checks in modelling tools. |
| **Assessment pointers**                          | Evaluate: correct use of start/end events, clarity of VERB-NOUN labels, replication of message flows across levels, explicit end states that map to gateways, and compactness/readability of the top diagram. |

---

# * Applied Data Science – TDT4259

**Content:**  
- Lifecycle of a data science project (CRISP-DM phases: business understanding, data understanding, preparation, modeling, evaluation, deployment, monitoring)  
- Data analytics types: descriptive, diagnostic, predictive, prescriptive  
- Data sources, quality issues, preparation, and feature engineering  
- Business problem framing, value creation, and data-driven decision-making  
- Documentation practices: one-pagers and design documents (Why–What–How)  
- Tools and techniques for data collection, exploration, modeling, and visualization  
- Group projects: solving real-world problems with open or provided datasets  
- Individual assignments: design docs for proposed data-driven solutions  
- Ethics and responsible data science (privacy, bias, fairness, societal impact)

**Learning outcome:**  
- **Knowledge:** Understand the phases of CRISP-DM; know the main types of data analytics and when to apply them; grasp principles of data preparation, quality assessment, and monitoring; recognize ethical issues in applied data science.  
- **Skills:** Frame and structure business problems into data science tasks; collect, prepare, and analyze data; evaluate models against business objectives; document and communicate solutions via one-pagers, design docs, and visualizations.  
- **General competence:** Apply data science methods to create value for organizations; work effectively in teams on real-world projects; reflect critically on ethical and societal impacts of data-driven decision-making.


### > Applied Data Science – Part 3 - TDT4259
---
*Dedicated to [Lecture 3 – Lifecycle of a Data Science Project](https://www.flexiquiz.com/SC/N/applieddatascience3).*  
*Reflects core TDT4259 Lesson 3 topics: CRISP-DM methodology, data analytics types, one-pagers & design docs, business understanding, data understanding, data preparation, Aneo grid loss case study, and monitoring & maintenance.*

Quiz: [Applied Data Science – Part 3](https://www.flexiquiz.com/SC/N/applieddatascience3)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **CRISP-DM framework**                           | Business understanding → Data understanding → Data preparation → Modeling → Evaluation → Deployment → Monitoring |
| **Business understanding**                       | Clarify goals, scope, value, problem definition; often refine or reduce scope                |
| **Data understanding**                           | Collect, describe, explore, verify data quality; domain insights; detect anomalies/outliers  |
| **Data preparation**                             | Select, clean, construct, integrate, and format data for modeling                            |
| **Modeling**                                     | Apply statistical/ML methods; compare baselines; validate with metrics                      |
| **Evaluation**                                   | Check model results against business objectives; visualize insights                         |
| **Deployment**                                   | Translate results into actionable recommendations; plan implementation                      |
| **Monitoring & maintenance**                     | Track KPIs, retrain models, set alarms, dashboards, ensure business + technical health       |
| **Types of analytics**                           | Descriptive (what happened), Diagnostic (why), Predictive (what might happen), Prescriptive (what should we do) |
| **One-pagers**                                   | Summarize intent, desired outcome, deliverable, constraints                                 |
| **Design documents**                             | Capture Why, What, How (+ risks, infra, monitoring, cost); expensive but cheap → avoid waste |
| **Case study: Aneo grid loss**                   | Grid loss = produced – consumed electricity; data issues: missing/delayed values, small sets |
| **Assignment (Group)**                           | Solve a business problem with data; report + 5-min presentation                             |
| **Assignment (Individual)**                      | One-pager + ~10 page design doc; different dataset/company than group project               |

### > Applied Data Science – Part 4 - TDT4259
---
*Dedicated to [Lecture 4 – Data → Features → Algorithms](https://www.flexiquiz.com/SC/N/applieddatascience_4).*  
*Reflects core TDT4259 Lesson 4 topics: variables → features, feature engineering, missingness & low-variance filters, scaling/normalization, PCA, supervised vs unsupervised, core algorithms (k-NN, SVM, trees, Naïve Bayes, neural nets), evaluation metrics, and a leakage-free pipeline.*

Quiz: [Applied Data Science – Part 4](https://www.flexiquiz.com/SC/N/applieddatascience_4)

|                                                  |                                                                                             |
|--------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Variables → Features**                         | Variables = raw columns; **features = model-ready signals** (transformed/engineered variables). |
| **Feature engineering examples**                  | `age` → buckets, z-score; `price` → `log1p(price)`; `signup_datetime` → hour/day/recency; text → TF-IDF / embeddings; image → CNN embedding |
| **Missing Values Ratio**                         | Fraction of nulls in a column. Use it to decide drop vs impute; common thresholds: <10% simple impute, 10–30% smarter impute or flag, >30–50% drop or require justification |
| **Low-variance filter**                          | Remove near-constant features (e.g., same value >95–99% rows). Scale-sensitive — check predictive power before dropping. |
| **Scaling / Normalization**                      | Required for distance/dot-product/variance methods (kNN, SVM, PCA, many NN optimizers). Use StandardScaler by default; MinMax/Robust/MaxAbs depending on context. Always fit scalers inside CV pipeline. |
| **PCA (Principal Component Analysis)**           | Linear dimensionality reduction: center (and usually scale) → compute covariance or SVD → keep top components by explained variance (e.g., 80–95%). Good for correlated numeric features; linear and less interpretable. |
| **Supervised vs Unsupervised**                   | Supervised = X + y (classification/regression). Unsupervised = X only (clustering, PCA). |
| **Core algorithms — short**                      | **Nearest Centroid**: mean of each class; simple baseline. **k-NN**: local, distance-based; scale required. **Decision Trees**: greedy splits by impurity (Gini/entropy); no scaling required. **Random Forests / Ensembles**: robust, strong baselines. **Naïve Bayes**: generative, assumes conditional independence (great for text). **SVM**: max-margin; kernel trick for nonlinear boundaries; scale mandatory. **Neural Nets**: neurons = weighted sum + activation; deep nets learn hierarchical features; need data + tuning. |
| **Evaluation (regression)**                      | **MAE** (mean absolute error) — robust; **RMSE** — penalizes large errors more. |
| **Evaluation (classification)**                  | **Confusion matrix** (TP/FP/FN/TN). **Precision** = TP/(TP+FP). **Recall** = TP/(TP+FN). **Accuracy** = (TP+TN)/total (can mislead on imbalance). Use ROC/PR curves and choose thresholds per business needs. |
| **Likelihood vs Probability**                    | Probability: parameters fixed → probability of data (e.g., P(x|θ)). Likelihood: data fixed → how plausible parameters are given data (used for fitting models). |
| **Practical pipeline (safe defaults)**           | 1) Train/val/test split or K-fold CV. 2) Build pipeline: impute → encode → scale → (optional PCA/feature selection) → model. 3) Tune hyperparameters inside CV. 4) Final evaluation on untouched test set. |
| **Feature/leakage warning**                       | Never compute scalers/encoders/statistics on full dataset before CV—this leaks info. Create "missing" indicator flags when missingness may be informative. |
| **When to prefer which method**                   | Text/sparse: Naïve Bayes, Linear models. Mixed types/interpretability: Trees/RandomForest. Smooth numeric boundaries: SVM. Complex high-D patterns (images/audio): Deep nets. k-NN for quick, small datasets / nonparametric baseline. |
| **Quick sklearn pipeline example**                | See code block below for a leakage-free pipeline (impute + scale + PCA + SVM). |