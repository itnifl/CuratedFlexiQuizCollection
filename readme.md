## ğŸ“š My FlexiQuiz Learning Series

Welcome to my curated collection of quizzes hosted on [FlexiQuiz](https://www.flexiquiz.com). These assessments are designed to test and reinforce knowledge across a variety of technical domains including **software testing**, **Java programming**, **cryptography**,  **software security**, and **algorithms + data structures**.

Each quiz has been crafted to balance core theory with real-world application and critical thinking. Many of them are content from subjects at NTNU Trondheim, several of them are old exams questions from previous exams.

---

## Software Testing and Quality Series - TDT4242

A series focused on core software testing concepts, methodologies, and best practices.

TDT4242 - â€œAdvanced Software Engineeringâ€ is a 7.5â€‘ECTS springâ€‘semester course at NTNU that deepens your ability to engineer smart, safetyâ€‘critical and otherwise complex softwareâ€‘intensive systems. Delivered in English, it is organised into four interconnected modules - (1) requirements specification, where you learn to transform stakeholder wishes into precise, highâ€‘quality technical requirements; (2) testing management, which surveys modern testâ€‘planning and testâ€‘automation strategies; (3) codeâ€‘quality improvement, covering static analysis, peer review and systematic refactoring; and (4) verification & validation of largeâ€‘scale or AIâ€‘assisted systems. Weekly lectures are paired with mandatory exercises and a group project in which you practise requirements engineering, design targeted test suites, and refactor real code bases. By the end you should be able to diagnose requirement flaws, select and apply suitable test and codeâ€‘review techniques, and critically assess emerging AIâ€‘supported development tools. The course assumes prior experience in web development and Python/JavaScript (e.g., TDT4140) and is assessed by a fourâ€‘hour written school exam (letter grading), with approved coursework as a prerequisite for sitting the exam,

- [Software Testing and Quality Quiz â€“ Part 1](https://www.flexiquiz.com/SC/N/SoftwareTesting1)  
  Covers basic testing terminology, unit testing, and manual testing fundamentals.

- [Software Testing and Quality Quiz â€“ Part 2](https://www.flexiquiz.com/SC/N/SoftwareTesting2)  
  Explores automated testing, integration testing, and test strategies.

- [Software Testing and Quality Quiz â€“ Part 3](https://www.flexiquiz.com/SC/N/SoftwareTesting3)  
  Delves into testing methodologies.

- [Software Testing and Quality Quiz â€“ Part 4](https://www.flexiquiz.com/SC/N/SoftwareTesting4)  
  Examines advanced topics like performance testing and test coverage metrics.

- [Software Testing and Quality Quiz â€“ Part 5](https://www.flexiquiz.com/SC/N/SoftwareTesting5) \
  Explores requirements engineering and test setup.

- [Software Testing and Quality Quiz â€“ Part 6](https://www.flexiquiz.com/SC/N/SoftwareTesting6) \
  Explores code smells, DU-coverage and Devops.

- [Software Testing and Quality Quiz â€“ Part 7](https://www.flexiquiz.com/SC/N/SoftwareTesting7) \
  Explores domain testing, code smells, sustainability, all-pair combinatorial tests, and Devops terms

- [Software Testing and Quality Quiz - Part 8](https://www.flexiquiz.com/SC/N/SoftwareTesting8) \
  Explores code refactoring, testing concepts, requirements quality, requirements classification, sustainable software requirements, branch and statement coverage.

---

## Java Programming - TDT4100

A foundational Java quiz for programmers looking to evaluate their language knowledge.

- [Java Programming Exam](https://www.flexiquiz.com/SC/N/JavaExam1)  
  Tests key concepts such as OOP principles, control structures, collections, and exception handling.

---

## Cryptography Fundamentals - TDT4237

A concise introduction to the world of secure communications and encryption techniques.

- [Cryptography Basics Quiz](https://www.flexiquiz.com/SC/N/Cryptography1)  
  Includes questions on symmetric/asymmetric encryption, hashing, and digital signatures.

---

## Software Security Series - TDT4237

A comprehensive series covering secure development practices and application-level security.

- [Software Security â€“ Part 1](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart1)  
  Intro to secure coding principles and threat modeling.

- [Software Security â€“ Part 2](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart2)  
  Covers input validation, authentication mechanisms, and secure session handling.

- [Software Security â€“ Part 3](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart3)  
  Explores access control, privilege escalation, and logging.

- [Software Security â€“ Part 4](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart4)  
  Focuses on secure SDLC, code reviews, and static/dynamic security testing.

- [Software Security - Part 5](https://www.flexiquiz.com/SC/N/SoftwareSecurityPart5) \
  Focuses on threat modeling, security models, and general cybersecurity.

---

## Web Application Security Series - TDT4237

A deep dive into common web vulnerabilities and how to prevent them.

- [Web Security â€“ Part 1](https://www.flexiquiz.com/SC/N/WebSecPart1)  
  Explains fundamentals of HTTP security, cookies, and sessions.

- [Web Security â€“ Part 2](https://www.flexiquiz.com/SC/N/WebSecPart2)  
  Focus on XSS (Cross-site Scripting) and injection attacks.

- [Web Security â€“ Part 3](https://www.flexiquiz.com/SC/N/WebSecPart3)  
  Covers CSRF (Cross-site Request Forgery), CORS, and authentication flaws.

- [Web Security â€“ Part 4](https://www.flexiquiz.com/SC/N/WebSecPart4)  
  Explores secure headers, TLS, and firewalls.

---

## Algorithms and Data Structures - TDT4120

TDT4120â€¯- â€œAlgorithms and Data Structuresâ€ is a 7.5â€‘ECTS intermediate course at NTNU that runs every autumn and equips students to design, analyse and implement efficient algorithms. Lectures and compulsory exercises take you from asymptotic efficiency analysis and divideâ€‘andâ€‘conquer recursion through classic ordering, searching, sorting and hashing techniques, on to dynamicâ€‘programming and greedy paradigms, advanced graph structures, shortestâ€‘path, matching, spanningâ€‘tree and maximumâ€‘flow algorithms, and the fundamentals of complexity theory. By the end, youâ€™re expected to recognise a broad repertoire of established algorithms, evaluate their timeâ€‘ and spaceâ€‘costs, and craft new solutions when none existâ€”competence that underpins later AI, cyberâ€‘security and systems courses. Instruction is Norwegianâ€‘language, the set text is Introduction to Algorithms (CLRSâ€¯4áµ—Ê°â€¯ed.), and assessment is a fourâ€‘hour written school exam.

- [Algorithms and Data Structures â€“ Part 1](https://www.flexiquiz.com/SC/N/Algdat1)  
  The 25â€‘page quiz is a concise tour of firstâ€‘semester algorithmic thinking: it opens with complexity theory, spotlighting NPâ€‘completeness and the domino effect of an efficient solution to any NPâ€‘complete problem; then it revisits classic combinatorial challenges such as the Travelingâ€‘Salesperson and shortestâ€‘path problems while contrasting scenarios that demand exact answers with those where nearâ€‘optimal suffices, and highlights the difference between offline and online algorithm settings. Practical correctness proofs follow, using loop invariants on a simple SUMâ€‘ARRAY routine, before turning to selection sortâ€™s invariant, loop bound, and Î˜â€‘time analysis, plus linear searchâ€™s average and worst cases and a thought experiment on forcing a â€œgoodâ€ best case for any sort. Divideâ€‘andâ€‘conquer appears through a fillâ€‘inâ€‘theâ€‘blank Masterâ€‘Theorem template and a Î˜(nâ€¯logâ€¯n) twoâ€‘sum algorithm, and the quiz closes with ranking common growth rates, simplifying asymptotic expressions, and converting polynomials to tight Î˜â€‘notationâ€”together forming a compact checklist of essential algorithmâ€‘analysis skills.

- [Algorithms and Data Structures â€“ Part 2](https://www.flexiquiz.com/SC/N/Algdat2)  
  This quiz walks you through the entire â€œalgorithms and dataâ€‘structures toolbox,â€ starting with the language of growth ratesâ€”matching expressions likeâ€¯lgâ€¯n,â€¯âˆšn,â€¯nâ€¯logâ€¯n,â€¯2â¿, andâ€¯n! to their names and interpreting Bigâ€‘O,â€¯Î˜,â€¯Î©,â€¯o, andâ€¯Ï‰ symbolsâ€”before testing your ability to classify real formulas and combine asymptotic bounds. It then shifts to practical algorithm analysis: you compare Insertion Sort, Merge Sort, and Quicksort across best, average, and worst cases; dig into how the Relaxâ€¯(u,â€¯v,â€¯w) operation underpins Dijkstraâ€™s and how Bellmanâ€‘Ford differs; and review Kruskalâ€™s role in building minimumâ€‘spanning trees. Advanced sections probe a proposed Newâ€‘SSSP method, examine why simply proving the greedyâ€‘choice property isnâ€™t enough, and ask you to debate pseudopolynomial versus NPâ€‘hard claims around Fordâ€‘Fulkerson and hyperflows. The final question highlights how choosing the right pivot can make or break Quicksortâ€™s performance, tying algorithm theory back to implementation details.

- [Algorithms and Data Structures â€“ Part 3](https://www.flexiquiz.com/SC/N/Algdat3)  
  The third quiz surveys intermediateâ€‘level algorithmic design and analysis: it starts with the greedyâ€‘choice property and when greedy methods work, then moves into dataâ€‘structure tradeâ€‘offsâ€”evaluating selection sort enhanced with a binaryâ€‘search tree, comparing heaps, binary trees and selfâ€‘adjusting splay trees. Next comes optimization technique: why naÃ¯ve recursion explodes, how memoization/dynamic programming rescues it, and what structural properties enable that speedâ€‘up. A block of questions contrasts classic and randomized algorithms (Quicksort versus Randomized Quicksort, Select versus Randomized Select, and what happens when Select drives Quicksort) and checks understanding of insertion, merge, quick, randomized quick and heap sort behaviors. Complexity theory follows: identifying classes such as NP and NPâ€‘complete and their verification versus solution difficulty. The quiz then tackles graph algorithmsâ€”minimumâ€‘spanning trees (Prim vsâ€¯Kruskal), the Fordâ€‘Fulkerson maxâ€‘flow method and why its runâ€‘time depends on capacity sizeâ€”before revisiting the Master Theorem and finishing with maximum, average and bestâ€‘case bounds for heap sort. Overall, it presses students to connect algorithmic paradigms, dataâ€‘structure choices, and asymptotic reasoning across a spectrum of classic problems.

- [Algorithms and Data Structures â€“ Part 4](https://www.flexiquiz.com/SC/N/Algdat4)  
  This fourth installment drills deep into asymptotic reasoning: you extend the classic crossing argument to derive an Î©(nÂ²) lower bound for insertion sort when the Î±â€¯n largest keys start up front, figure out the Î± that maximizes crossings, and refine the necessary constraints on Î±. You then prove and debunk common Bigâ€‘O claimsâ€”why max{f,g}=Î˜(f+g), why â€œat least O(nÂ²)â€ is meaningless, and why no function can lie in both o(g) and Ï‰(g). Quickâ€‘fire questions test your ability to manipulate Î±â€‘weighted sums, spot when factorials of logarithms outgrow polynomials, and solve kâ€¯logâ€¯kâ€¯=â€¯Î˜(n). The quiz finishes with a flurry of Masterâ€‘Theorem puzzles: parsing parameters, selecting the right case, and tying a generic divideâ€‘andâ€‘conquer template back to Merge Sort. Together the problems weave concrete algorithm examples with rigorous asymptotic definitions, sharpening both proof technique and recurrenceâ€‘cracking speed.

- [Algorithms and Data Structures â€“ Part 5](https://www.flexiquiz.com/SC/N/Algdat5)  
The Quiz 5 sequence surveys foundational concepts and techniques in algorithm analysis and sorting, including: comparing growth rates with Big-O, Î˜ and o notation; ranking common complexity classes from constant through super-exponential; identifying valid asymptotic relationships; combining Î˜, O and Î© bounds into tight characterizations; recognizing which algorithms use divide-and-conquer; naming and understanding binary search; merge-sortâ€™s divide-and-merge pattern; quick-sortâ€™s partitioning routine; counting sort and its stable, key-counting approach; radix sortâ€™s digit-by-digit bucket processing; bucket sortâ€™s uniform-distribution strategy; bubble sortâ€™s simple compare-and-swap loops; filling out best, average and worst-case tables for comparison-based sorts; pinpointing pivot choices that trigger worst-case Î˜(nÂ²) versus randomized or median-of-medians guarantees of Î˜(n log n); understanding the practical benefit of median-of-three pivots and how pivot choice affects stability; selecting strategies that ensure good or bad partitions; and, finally, describing the left-child/right-sibling tree representation for arbitrary-arity rooted trees.

- [Algorithms and Data Structures â€“ Part 6](https://www.flexiquiz.com/SC/N/Algdat6)  
The quiz covers a range of core topics in algorithms and data structures, including: the extra information needed to turn a free tree into a rooted tree; the height of a complete binary tree; indexing children in a binary heap; the max-heap invariant and the running times of BUILD-MAX-HEAP and MAX-HEAPIFY; why a heap cannot satisfy the BST property; the expected height of a random BST versus data structures that guarantee logarithmic height; the cost of removing the maximum or retrieving the top-k elements from a heap; the left-child/right-sibling representation and its pointer overhead; conditions for achieving amortized O(1) updates and queries in bucket arrays; the time to print a BST in sorted order; why unbalanced BST operations can degrade to Î˜(n) while heap operations remain Î˜(log n); distinguishing the heap property from the heap invariant; the effect of one iteration of Heapsort on a given array; the trade-offs between building a heap via repeated inserts versus BUILD-HEAP in Primâ€™s algorithm; the fundamental difference between BST and heap ordering; definitions and algorithms for finding spanning trees; the pros and cons of replacing the selection-sort scan with a BST (tree-sort) versus using a heap (Heapsort); the relationship between repeated algorithmic steps, problem decomposition, design paradigms, induction proofs, and hardness reductions; and finally, the mechanics of performing HEAP-EXTRACT-MAX on an (invalid) heap array.


**TDT4120 - Resources:**

- [VisuAlgo: Sorting](https://visualgo.net/en/sorting)
- [henrhoi/Algdat-TDT4120 (GitHub)](https://github.com/henrhoi/Algdat-TDT4120)
- [Xtrah/TDT4120 (GitHub)](https://github.com/Xtrah/TDT4120)

- [NTNU TDT4120 â€” Algorithms and Data Structures (official course page)](https://www.ntnu.edu/studies/courses/TDT4120). 
- [CP-Algorithms â€” Algorithms for Competitive Programming](https://cp-algorithms.com/).


---
